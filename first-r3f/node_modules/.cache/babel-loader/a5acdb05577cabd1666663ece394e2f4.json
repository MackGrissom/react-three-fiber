{"ast":null,"code":"import { GridHelper, EllipseCurve, BufferGeometry, Line, LineBasicMaterial, Raycaster, Group, Box3, Sphere, Quaternion, Vector2, Vector3, Matrix4, MathUtils, EventDispatcher } from 'three'; //trackball state\n\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n}; //cursor center coordinates\n\nconst _center = {\n  x: 0,\n  y: 0\n}; //transformation matrices for gizmos and camera\n\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n}; //events\n\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\n\nconst _raycaster = new Raycaster();\n\nconst _offset = new Vector3();\n\nconst _gizmoMatrixStateTemp = new Matrix4();\n\nconst _cameraMatrixStateTemp = new Matrix4();\n\nconst _scalePointTemp = new Vector3();\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\n\n\nclass ArcballControls extends EventDispatcher {\n  constructor(camera, domElement) {\n    let scene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super();\n    this.camera = null;\n    this.domElement = domElement;\n    this.scene = scene;\n    this.target = new Vector3();\n    this._currentTarget = new Vector3();\n    this.radiusFactor = 0.67;\n    this.mouseActions = [];\n    this._mouseOp = null; //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion(); //transformation matrices\n\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\n\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n    this._rotationAxis = new Vector3(); //axis for rotate operation\n    //camera state\n\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4(); //initial values\n\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4(); //pointers array\n\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE; //two fingers touch interaction\n\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\n\n    this._startFingerDistance = 0; //distance between two fingers\n\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\n\n    this._currentFingerRotation = 0; //double tap\n\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._downStart = 0; //pointerDown time\n\n    this._clickStart = 0; //first click time\n\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24; //cursor positions\n\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3(); //grid\n\n    this._grid = null; //grid to be visualized during pan operation\n\n    this._gridPosition = new Vector3(); //gizmos\n\n    this._gizmos = new Group();\n    this._curvePts = 128; //animations\n\n    this._timeStart = -1; //initial time\n\n    this._animationId = -1; //focus animation\n\n    this.focusAnimationTime = 500; //duration of focus animation in ms\n    //rotate animation\n\n    this._timePrev = 0; //time at which previous rotate operation has been detected\n\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\n\n    this._anglePrev = 0; //angle of previous rotation\n\n    this._angleCurrent = 0; //angle of current rotation\n\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\n\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\n\n    this._wPrev = 0; //angular velocity of the previous rotate operation\n\n    this._wCurr = 0; //angular velocity of the current rotate operation\n    //parameters\n\n    this.adjustNearFar = false;\n    this.scaleFactor = 1.1; //zoom/distance multiplier\n\n    this.dampingFactor = 25;\n    this.wMax = 20; //maximum angular velocity allowed\n\n    this.enableAnimations = true; //if animations should be performed\n\n    this.enableGrid = false; //if grid should be showed during pan operation\n\n    this.cursorZoom = false; //if wheel zoom should be cursor centered\n\n    this.minFov = 5;\n    this.maxFov = 90;\n    this.enabled = true;\n    this.enablePan = true;\n    this.enableRotate = true;\n    this.enableZoom = true;\n    this.enableGizmos = true;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity; //trackball parameters\n\n    this._tbRadius = 1; //FSA\n\n    this._state = STATE.IDLE;\n    this.setCamera(camera);\n\n    if (this.scene != null) {\n      this.scene.add(this._gizmos);\n    }\n\n    this.domElement.style.touchAction = 'none';\n    this._devPxRatio = window.devicePixelRatio;\n    this.initializeMouseActions();\n    this.domElement.addEventListener('contextmenu', this.onContextMenu);\n    this.domElement.addEventListener('wheel', this.onWheel);\n    this.domElement.addEventListener('pointerdown', this.onPointerDown);\n    this.domElement.addEventListener('pointercancel', this.onPointerCancel);\n    window.addEventListener('resize', this.onWindowResize);\n  } //listeners\n\n\n  onWindowResize = () => {\n    const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n    this._tbRadius = this.calculateTbRadius(this.camera);\n    const newRadius = this._tbRadius / scale;\n    const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n    const points = curve.getPoints(this._curvePts);\n    const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n    for (const gizmo in this._gizmos.children) {\n      this._gizmos.children[gizmo].geometry = curveGeometry;\n    }\n\n    this.dispatchEvent(_changeEvent);\n  };\n  onContextMenu = event => {\n    if (!this.enabled) {\n      return;\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == 2) {\n        //prevent only if button 2 is actually used\n        event.preventDefault();\n        break;\n      }\n    }\n  };\n  onPointerCancel = () => {\n    this._touchStart.splice(0, this._touchStart.length);\n\n    this._touchCurrent.splice(0, this._touchCurrent.length);\n\n    this._input = INPUT.NONE;\n  };\n  onPointerDown = event => {\n    if (event.button == 0 && event.isPrimary) {\n      this._downValid = true;\n\n      this._downEvents.push(event);\n\n      this._downStart = performance.now();\n    } else {\n      this._downValid = false;\n    }\n\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      this._touchStart.push(event);\n\n      this._touchCurrent.push(event);\n\n      switch (this._input) {\n        case INPUT.NONE:\n          //singleStart\n          this._input = INPUT.ONE_FINGER;\n          this.onSinglePanStart(event, 'ROTATE');\n          window.addEventListener('pointermove', this.onPointerMove);\n          window.addEventListener('pointerup', this.onPointerUp);\n          break;\n\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //doubleStart\n          this._input = INPUT.TWO_FINGER;\n          this.onRotateStart();\n          this.onPinchStart();\n          this.onDoublePanStart();\n          break;\n\n        case INPUT.TWO_FINGER:\n          //multipleStart\n          this._input = INPUT.MULT_FINGER;\n          this.onTriplePanStart(event);\n          break;\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n      let modifier = null;\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL';\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT';\n      }\n\n      this._mouseOp = this.getOpFromAction(event.button, modifier);\n\n      if (this._mouseOp != null) {\n        window.addEventListener('pointermove', this.onPointerMove);\n        window.addEventListener('pointerup', this.onPointerUp); //singleStart\n\n        this._input = INPUT.CURSOR;\n        this._button = event.button;\n        this.onSinglePanStart(event, this._mouseOp);\n      }\n    }\n  };\n  onPointerMove = event => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n          //singleMove\n          this.updateTouchEvent(event);\n          this.onSinglePanMove(event, STATE.ROTATE);\n          break;\n\n        case INPUT.ONE_FINGER_SWITCHED:\n          const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n\n          if (movement >= this._switchSensibility) {\n            //singleMove\n            this._input = INPUT.ONE_FINGER;\n            this.updateTouchEvent(event);\n            this.onSinglePanStart(event, 'ROTATE');\n            break;\n          }\n\n          break;\n\n        case INPUT.TWO_FINGER:\n          //rotate/pan/pinchMove\n          this.updateTouchEvent(event);\n          this.onRotateMove();\n          this.onPinchMove();\n          this.onDoublePanMove();\n          break;\n\n        case INPUT.MULT_FINGER:\n          //multMove\n          this.updateTouchEvent(event);\n          this.onTriplePanMove(event);\n          break;\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      let modifier = null;\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL';\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT';\n      }\n\n      const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n\n      if (mouseOpState != null) {\n        this.onSinglePanMove(event, mouseOpState);\n      }\n    } //checkDistance\n\n\n    if (this._downValid) {\n      const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n\n      if (movement > this._movementThreshold) {\n        this._downValid = false;\n      }\n    }\n  };\n  onPointerUp = event => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      const nTouch = this._touchCurrent.length;\n\n      for (let i = 0; i < nTouch; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1);\n\n          this._touchStart.splice(i, 1);\n\n          break;\n        }\n      }\n\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //singleEnd\n          window.removeEventListener('pointermove', this.onPointerMove);\n          window.removeEventListener('pointerup', this.onPointerUp);\n          this._input = INPUT.NONE;\n          this.onSinglePanEnd();\n          break;\n\n        case INPUT.TWO_FINGER:\n          //doubleEnd\n          this.onDoublePanEnd(event);\n          this.onPinchEnd(event);\n          this.onRotateEnd(event); //switching to singleStart\n\n          this._input = INPUT.ONE_FINGER_SWITCHED;\n          break;\n\n        case INPUT.MULT_FINGER:\n          if (this._touchCurrent.length == 0) {\n            window.removeEventListener('pointermove', this.onPointerMove);\n            window.removeEventListener('pointerup', this.onPointerUp); //multCancel\n\n            this._input = INPUT.NONE;\n            this.onTriplePanEnd();\n          }\n\n          break;\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      window.removeEventListener('pointermove', this.onPointerMove);\n      window.removeEventListener('pointerup', this.onPointerUp);\n      this._input = INPUT.NONE;\n      this.onSinglePanEnd();\n      this._button = -1;\n    }\n\n    if (event.isPrimary) {\n      if (this._downValid) {\n        const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n\n        if (downTime <= this._maxDownTime) {\n          if (this._nclicks == 0) {\n            //first valid click detected\n            this._nclicks = 1;\n            this._clickStart = performance.now();\n          } else {\n            const clickInterval = event.timeStamp - this._clickStart;\n\n            const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n\n            if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n              //second valid click detected\n              //fire double tap and reset values\n              this._nclicks = 0;\n\n              this._downEvents.splice(0, this._downEvents.length);\n\n              this.onDoubleTap(event);\n            } else {\n              //new 'first click'\n              this._nclicks = 1;\n\n              this._downEvents.shift();\n\n              this._clickStart = performance.now();\n            }\n          }\n        } else {\n          this._downValid = false;\n          this._nclicks = 0;\n\n          this._downEvents.splice(0, this._downEvents.length);\n        }\n      } else {\n        this._nclicks = 0;\n\n        this._downEvents.splice(0, this._downEvents.length);\n      }\n    }\n  };\n  onWheel = event => {\n    if (this.enabled && this.enableZoom) {\n      let modifier = null;\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL';\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT';\n      }\n\n      const mouseOp = this.getOpFromAction('WHEEL', modifier);\n\n      if (mouseOp != null) {\n        event.preventDefault();\n        this.dispatchEvent(_startEvent);\n        const notchDeltaY = 125; //distance of one notch of mouse wheel\n\n        let sgn = event.deltaY / notchDeltaY;\n        let size = 1;\n\n        if (sgn > 0) {\n          size = 1 / this.scaleFactor;\n        } else if (sgn < 0) {\n          size = this.scaleFactor;\n        }\n\n        switch (mouseOp) {\n          case 'ZOOM':\n            this.updateTbState(STATE.SCALE, true);\n\n            if (sgn > 0) {\n              size = 1 / Math.pow(this.scaleFactor, sgn);\n            } else if (sgn < 0) {\n              size = Math.pow(this.scaleFactor, -sgn);\n            }\n\n            if (this.cursorZoom && this.enablePan) {\n              let scalePoint;\n\n              if (this.camera.isOrthographicCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n              } else if (this.camera.isPerspectiveCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n              }\n\n              this.applyTransformMatrix(this.scale(size, scalePoint));\n            } else {\n              this.applyTransformMatrix(this.scale(size, this._gizmos.position));\n            }\n\n            if (this._grid != null) {\n              this.disposeGrid();\n              this.drawGrid();\n            }\n\n            this.updateTbState(STATE.IDLE, false);\n            this.dispatchEvent(_changeEvent);\n            this.dispatchEvent(_endEvent);\n            break;\n\n          case 'FOV':\n            if (this.camera.isPerspectiveCamera) {\n              this.updateTbState(STATE.FOV, true); //Vertigo effect\n              //\t  fov / 2\n              //\t\t|\\\n              //\t\t| \\\n              //\t\t|  \\\n              //\tx\t|\t\\\n              //\t\t| \t \\\n              //\t\t| \t  \\\n              //\t\t| _ _ _\\\n              //\t\t\ty\n              //check for iOs shift shortcut\n\n              if (event.deltaX != 0) {\n                sgn = event.deltaX / notchDeltaY;\n                size = 1;\n\n                if (sgn > 0) {\n                  size = 1 / Math.pow(this.scaleFactor, sgn);\n                } else if (sgn < 0) {\n                  size = Math.pow(this.scaleFactor, -sgn);\n                }\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n              const x = this._v3_1.distanceTo(this._gizmos.position);\n\n              let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n              //check min and max distance\n\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n              const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5); //calculate new fov\n\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n              if (newFov > this.maxFov) {\n                newFov = this.maxFov;\n              } else if (newFov < this.minFov) {\n                newFov = this.minFov;\n              }\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n              size = x / newDistance;\n              this.setFov(newFov);\n              this.applyTransformMatrix(this.scale(size, this._gizmos.position, false));\n            }\n\n            if (this._grid != null) {\n              this.disposeGrid();\n              this.drawGrid();\n            }\n\n            this.updateTbState(STATE.IDLE, false);\n            this.dispatchEvent(_changeEvent);\n            this.dispatchEvent(_endEvent);\n            break;\n        }\n      }\n    }\n  };\n  onSinglePanStart = (event, operation) => {\n    if (this.enabled) {\n      this.dispatchEvent(_startEvent);\n      this.setCenter(event.clientX, event.clientY);\n\n      switch (operation) {\n        case 'PAN':\n          if (!this.enablePan) {\n            return;\n          }\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n\n          this.updateTbState(STATE.PAN, true);\n\n          this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n          if (this.enableGrid) {\n            this.drawGrid();\n            this.dispatchEvent(_changeEvent);\n          }\n\n          break;\n\n        case 'ROTATE':\n          if (!this.enableRotate) {\n            return;\n          }\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n          }\n\n          this.updateTbState(STATE.ROTATE, true);\n\n          this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n          this.activateGizmos(true);\n\n          if (this.enableAnimations) {\n            this._timePrev = this._timeCurrent = performance.now();\n            this._angleCurrent = this._anglePrev = 0;\n\n            this._cursorPosPrev.copy(this._startCursorPosition);\n\n            this._cursorPosCurr.copy(this._cursorPosPrev);\n\n            this._wCurr = 0;\n            this._wPrev = this._wCurr;\n          }\n\n          this.dispatchEvent(_changeEvent);\n          break;\n\n        case 'FOV':\n          if (!this.camera.isPerspectiveCamera || !this.enableZoom) {\n            return;\n          }\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n\n          this.updateTbState(STATE.FOV, true);\n\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n          this._currentCursorPosition.copy(this._startCursorPosition);\n\n          break;\n\n        case 'ZOOM':\n          if (!this.enableZoom) {\n            return;\n          }\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n\n          this.updateTbState(STATE.SCALE, true);\n\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n          this._currentCursorPosition.copy(this._startCursorPosition);\n\n          break;\n      }\n    }\n  };\n  onSinglePanMove = (event, opState) => {\n    if (this.enabled) {\n      const restart = opState != this._state;\n      this.setCenter(event.clientX, event.clientY);\n\n      switch (opState) {\n        case STATE.PAN:\n          if (this.enablePan) {\n            if (restart) {\n              //switch to pan operation\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n\n              this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n              if (this.enableGrid) {\n                this.drawGrid();\n              }\n\n              this.activateGizmos(false);\n            } else {\n              //continue with pan operation\n              this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n              this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n            }\n          }\n\n          break;\n\n        case STATE.ROTATE:\n          if (this.enableRotate) {\n            if (restart) {\n              //switch to rotate operation\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n\n              this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n\n              this.activateGizmos(true);\n            } else {\n              //continue with rotate operation\n              this._currentCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n              const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n\n              const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n\n              const amount = Math.max(distance / this._tbRadius, angle); //effective rotation angle\n\n              this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent;\n                this._timeCurrent = performance.now();\n                this._anglePrev = this._angleCurrent;\n                this._angleCurrent = amount;\n\n                this._cursorPosPrev.copy(this._cursorPosCurr);\n\n                this._cursorPosCurr.copy(this._currentCursorPosition);\n\n                this._wPrev = this._wCurr;\n                this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n              }\n            }\n          }\n\n          break;\n\n        case STATE.SCALE:\n          if (this.enableZoom) {\n            if (restart) {\n              //switch to zoom operation\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n              this._currentCursorPosition.copy(this._startCursorPosition);\n\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n\n              this.activateGizmos(false);\n            } else {\n              //continue with zoom operation\n              const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n              let size = 1;\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches);\n              }\n\n              this._v3_1.setFromMatrixPosition(this._gizmoMatrixState);\n\n              this.applyTransformMatrix(this.scale(size, this._v3_1));\n            }\n          }\n\n          break;\n\n        case STATE.FOV:\n          if (this.enableZoom && this.camera.isPerspectiveCamera) {\n            if (restart) {\n              //switch to fov operation\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n              this._currentCursorPosition.copy(this._startCursorPosition);\n\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n\n              this.activateGizmos(false);\n            } else {\n              //continue with fov operation\n              const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n              let size = 1;\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches);\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n              const x = this._v3_1.distanceTo(this._gizmos.position);\n\n              let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n              //check min and max distance\n\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n              const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n              newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n              size = x / newDistance;\n\n              this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n              this.setFov(newFov);\n              this.applyTransformMatrix(this.scale(size, this._v3_2, false)); //adjusting distance\n\n              _offset.copy(this._gizmos.position).sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n              this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n            }\n          }\n\n          break;\n      }\n\n      this.dispatchEvent(_changeEvent);\n    }\n  };\n  onSinglePanEnd = () => {\n    if (this._state == STATE.ROTATE) {\n      if (!this.enableRotate) {\n        return;\n      }\n\n      if (this.enableAnimations) {\n        //perform rotation animation\n        const deltaTime = performance.now() - this._timeCurrent;\n\n        if (deltaTime < 120) {\n          const w = Math.abs((this._wPrev + this._wCurr) / 2);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_ROTATE, true);\n            const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n            self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n          });\n        } else {\n          //cursor has been standing still for over 120 ms since last movement\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n      this.updateTbState(STATE.IDLE, false);\n\n      if (this.enableGrid) {\n        this.disposeGrid();\n      }\n\n      this.activateGizmos(false);\n      this.dispatchEvent(_changeEvent);\n    }\n\n    this.dispatchEvent(_endEvent);\n  };\n  onDoubleTap = event => {\n    if (this.enabled && this.enablePan && this.scene != null) {\n      this.dispatchEvent(_startEvent);\n      this.setCenter(event.clientX, event.clientY);\n      const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\n\n      if (hitP != null && this.enableAnimations) {\n        const self = this;\n\n        if (this._animationId != -1) {\n          window.cancelAnimationFrame(this._animationId);\n        }\n\n        this._timeStart = -1;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.updateTbState(STATE.ANIMATION_FOCUS, true);\n          self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n        });\n      } else if (hitP != null && !this.enableAnimations) {\n        this.updateTbState(STATE.FOCUS, true);\n        this.focus(hitP, this.scaleFactor);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    }\n\n    this.dispatchEvent(_endEvent);\n  };\n  onDoublePanStart = () => {\n    if (this.enabled && this.enablePan) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.PAN, true);\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n      this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n\n      this._currentCursorPosition.copy(this._startCursorPosition);\n\n      this.activateGizmos(false);\n    }\n  };\n  onDoublePanMove = () => {\n    if (this.enabled && this.enablePan) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n      if (this._state != STATE.PAN) {\n        this.updateTbState(STATE.PAN, true);\n\n        this._startCursorPosition.copy(this._currentCursorPosition);\n      }\n\n      this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n\n      this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n      this.dispatchEvent(_changeEvent);\n    }\n  };\n  onDoublePanEnd = () => {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n  };\n  onRotateStart = () => {\n    if (this.enabled && this.enableRotate) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.ZROTATE, true); //this._startFingerRotation = event.rotation;\n\n      this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n      this._currentFingerRotation = this._startFingerRotation;\n      this.camera.getWorldDirection(this._rotationAxis); //rotation axis\n\n      if (!this.enablePan && !this.enableZoom) {\n        this.activateGizmos(true);\n      }\n    }\n  };\n  onRotateMove = () => {\n    if (this.enabled && this.enableRotate) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      let rotationPoint;\n\n      if (this._state != STATE.ZROTATE) {\n        this.updateTbState(STATE.ZROTATE, true);\n        this._startFingerRotation = this._currentFingerRotation;\n      } //this._currentFingerRotation = event.rotation;\n\n\n      this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n\n      if (!this.enablePan) {\n        rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n      } else {\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n        rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\n      }\n\n      const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n      this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n      this.dispatchEvent(_changeEvent);\n    }\n  };\n  onRotateEnd = () => {\n    this.updateTbState(STATE.IDLE, false);\n    this.activateGizmos(false);\n    this.dispatchEvent(_endEvent);\n  };\n  onPinchStart = () => {\n    if (this.enabled && this.enableZoom) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.SCALE, true);\n      this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n      this._currentFingerDistance = this._startFingerDistance;\n      this.activateGizmos(false);\n    }\n  };\n  onPinchMove = () => {\n    if (this.enabled && this.enableZoom) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      const minDistance = 12; //minimum distance between fingers (in css pixels)\n\n      if (this._state != STATE.SCALE) {\n        this._startFingerDistance = this._currentFingerDistance;\n        this.updateTbState(STATE.SCALE, true);\n      }\n\n      this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n      const amount = this._currentFingerDistance / this._startFingerDistance;\n      let scalePoint;\n\n      if (!this.enablePan) {\n        scalePoint = this._gizmos.position;\n      } else {\n        if (this.camera.isOrthographicCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n        } else if (this.camera.isPerspectiveCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n        }\n      }\n\n      this.applyTransformMatrix(this.scale(amount, scalePoint));\n      this.dispatchEvent(_changeEvent);\n    }\n  };\n  onPinchEnd = () => {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n  };\n  onTriplePanStart = () => {\n    if (this.enabled && this.enableZoom) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.SCALE, true); //const center = event.center;\n\n      let clientX = 0;\n      let clientY = 0;\n      const nFingers = this._touchCurrent.length;\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX;\n        clientY += this._touchCurrent[i].clientY;\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers);\n\n      this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n      this._currentCursorPosition.copy(this._startCursorPosition);\n    }\n  };\n  onTriplePanMove = () => {\n    if (this.enabled && this.enableZoom) {\n      //\t  fov / 2\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\tx\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t\t| _ _ _\\\n      //\t\t\ty\n      //const center = event.center;\n      let clientX = 0;\n      let clientY = 0;\n      const nFingers = this._touchCurrent.length;\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX;\n        clientY += this._touchCurrent[i].clientY;\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers);\n      const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n      this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n      const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n      let size = 1;\n\n      if (movement < 0) {\n        size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n      } else if (movement > 0) {\n        size = Math.pow(this.scaleFactor, movement * screenNotches);\n      }\n\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n      const x = this._v3_1.distanceTo(this._gizmos.position);\n\n      let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n      //check min and max distance\n\n      xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n      const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n      let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n      newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n      const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n      size = x / newDistance;\n\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n      this.setFov(newFov);\n      this.applyTransformMatrix(this.scale(size, this._v3_2, false)); //adjusting distance\n\n      _offset.copy(this._gizmos.position).sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n      this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n\n      this.dispatchEvent(_changeEvent);\n    }\n  };\n  onTriplePanEnd = () => {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent); //this.dispatchEvent( _changeEvent );\n  };\n  /**\n   * Set _center's x/y coordinates\n   * @param {Number} clientX\n   * @param {Number} clientY\n   */\n\n  setCenter = (clientX, clientY) => {\n    _center.x = clientX;\n    _center.y = clientY;\n  };\n  /**\n   * Set default mouse actions\n   */\n\n  initializeMouseActions = () => {\n    this.setMouseAction('PAN', 0, 'CTRL');\n    this.setMouseAction('PAN', 2);\n    this.setMouseAction('ROTATE', 0);\n    this.setMouseAction('ZOOM', 'WHEEL');\n    this.setMouseAction('ZOOM', 1);\n    this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\n    this.setMouseAction('FOV', 1, 'SHIFT');\n  };\n  /**\n   * Compare two mouse actions\n   * @param {Object} action1\n   * @param {Object} action2\n   * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise\n   */\n\n  compareMouseAction = (action1, action2) => {\n    if (action1.operation == action2.operation) {\n      if (action1.mouse == action2.mouse && action1.key == action2.key) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n   * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n   */\n\n  setMouseAction = (() => {\n    var _this = this;\n\n    return function (operation, mouse) {\n      let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\n      const mouseInput = [0, 1, 2, 'WHEEL'];\n      const keyInput = ['CTRL', 'SHIFT', null];\n      let state;\n\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        //invalid parameters\n        return false;\n      }\n\n      if (mouse == 'WHEEL') {\n        if (operation != 'ZOOM' && operation != 'FOV') {\n          //cannot associate 2D operation to 1D input\n          return false;\n        }\n      }\n\n      switch (operation) {\n        case 'PAN':\n          state = STATE.PAN;\n          break;\n\n        case 'ROTATE':\n          state = STATE.ROTATE;\n          break;\n\n        case 'ZOOM':\n          state = STATE.SCALE;\n          break;\n\n        case 'FOV':\n          state = STATE.FOV;\n          break;\n      }\n\n      const action = {\n        operation: operation,\n        mouse: mouse,\n        key: key,\n        state: state\n      };\n\n      for (let i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == action.mouse && _this.mouseActions[i].key == action.key) {\n          _this.mouseActions.splice(i, 1, action);\n\n          return true;\n        }\n      }\n\n      _this.mouseActions.push(action);\n\n      return true;\n    };\n  })();\n  /**\n   * Remove a mouse action by specifying its mouse/key combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the operation has been succesfully removed, false otherwise\n   */\n\n  unsetMouseAction = (() => {\n    var _this2 = this;\n\n    return function (mouse) {\n      let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      for (let i = 0; i < _this2.mouseActions.length; i++) {\n        if (_this2.mouseActions[i].mouse == mouse && _this2.mouseActions[i].key == key) {\n          _this2.mouseActions.splice(i, 1);\n\n          return true;\n        }\n      }\n\n      return false;\n    };\n  })();\n  /**\n   * Return the operation associated to a mouse/keyboard combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns The operation if it has been found, null otherwise\n   */\n\n  getOpFromAction = (mouse, key) => {\n    let action;\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i];\n\n      if (action.mouse == mouse && action.key == key) {\n        return action.operation;\n      }\n    }\n\n    if (key != null) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == null) {\n          return action.operation;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n   * @param {Number} mouse Mouse button\n   * @param {String} key Keyboard modifier\n   * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n   */\n\n  getOpStateFromAction = (mouse, key) => {\n    let action;\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i];\n\n      if (action.mouse == mouse && action.key == key) {\n        return action.state;\n      }\n    }\n\n    if (key != null) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == null) {\n          return action.state;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Calculate the angle between two pointers\n   * @param {PointerEvent} p1\n   * @param {PointerEvent} p2\n   * @returns {Number} The angle between two pointers in degrees\n   */\n\n  getAngle = (p1, p2) => {\n    return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n  };\n  /**\n   * Update a PointerEvent inside current pointerevents array\n   * @param {PointerEvent} event\n   */\n\n  updateTouchEvent = event => {\n    for (let i = 0; i < this._touchCurrent.length; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1, event);\n\n        break;\n      }\n    }\n  };\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n\n  applyTransformMatrix(transformation) {\n    if (transformation.camera != null) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.updateMatrix(); //update camera up vector\n\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n      }\n    }\n\n    if (transformation.gizmos != null) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.updateMatrix();\n    }\n\n    if (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) {\n      this._tbRadius = this.calculateTbRadius(this.camera);\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.camera.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.camera.far = cameraDistance - minFarPos;\n        this.camera.updateProjectionMatrix();\n      } else {\n        let update = false;\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear;\n          update = true;\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar;\n          update = true;\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n\n\n  calculateAngularSpeed = (p0, p1, t0, t1) => {\n    const s = p1 - p0;\n    const t = (t1 - t0) / 1000;\n\n    if (t == 0) {\n      return 0;\n    }\n\n    return s / t;\n  };\n  /**\n   * Calculate the distance between two pointers\n   * @param {PointerEvent} p0 The first pointer\n   * @param {PointerEvent} p1 The second pointer\n   * @returns {number} The distance between the two pointers\n   */\n\n  calculatePointersDistance = (p0, p1) => {\n    return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n  };\n  /**\n   * Calculate the rotation axis as the vector perpendicular between two vectors\n   * @param {Vector3} vec1 The first vector\n   * @param {Vector3} vec2 The second vector\n   * @returns {Vector3} The normalized rotation axis\n   */\n\n  calculateRotationAxis = (vec1, vec2) => {\n    this._rotationMatrix.extractRotation(this._cameraMatrixState);\n\n    this._quat.setFromRotationMatrix(this._rotationMatrix);\n\n    this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n\n    return this._rotationAxis.normalize().clone();\n  };\n  /**\n   * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n   * @param {Camera} camera\n   * @returns {Number} The trackball radius\n   */\n\n  calculateTbRadius = camera => {\n    const distance = camera.position.distanceTo(this._gizmos.position);\n\n    if (camera.type == 'PerspectiveCamera') {\n      const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\n      const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\n\n      return Math.tan(Math.min(halfFovV, halfFovH)) * distance * this.radiusFactor;\n    } else if (camera.type == 'OrthographicCamera') {\n      return Math.min(camera.top, camera.right) * this.radiusFactor;\n    }\n  };\n  /**\n   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n   * @param {Vector3} point The point of interest\n   * @param {Number} size Scale factor\n   * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n   */\n\n  focus = (() => {\n    var _this3 = this;\n\n    return function (point, size) {\n      let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      //move center of camera (along with gizmos) towards point of interest\n      _offset.copy(point).sub(_this3._gizmos.position).multiplyScalar(amount);\n\n      _this3._translationMatrix.makeTranslation(_offset.x, _offset.y, _offset.z);\n\n      _gizmoMatrixStateTemp.copy(_this3._gizmoMatrixState);\n\n      _this3._gizmoMatrixState.premultiply(_this3._translationMatrix);\n\n      _this3._gizmoMatrixState.decompose(_this3._gizmos.position, _this3._gizmos.quaternion, _this3._gizmos.scale);\n\n      _cameraMatrixStateTemp.copy(_this3._cameraMatrixState);\n\n      _this3._cameraMatrixState.premultiply(_this3._translationMatrix);\n\n      _this3._cameraMatrixState.decompose(_this3.camera.position, _this3.camera.quaternion, _this3.camera.scale); //apply zoom\n\n\n      if (_this3.enableZoom) {\n        _this3.applyTransformMatrix(_this3.scale(size, _this3._gizmos.position));\n      }\n\n      _this3._gizmoMatrixState.copy(_gizmoMatrixStateTemp);\n\n      _this3._cameraMatrixState.copy(_cameraMatrixStateTemp);\n    };\n  })();\n  /**\n   * Draw a grid and add it to the scene\n   */\n\n  drawGrid = () => {\n    if (this.scene != null) {\n      const color = 0x888888;\n      const multiplier = 3;\n      let size, divisions, maxLength, tick;\n\n      if (this.camera.isOrthographicCamera) {\n        const width = this.camera.right - this.camera.left;\n        const height = this.camera.bottom - this.camera.top;\n        maxLength = Math.max(width, height);\n        tick = maxLength / 20;\n        size = maxLength / this.camera.zoom * multiplier;\n        divisions = size / tick * this.camera.zoom;\n      } else if (this.camera.isPerspectiveCamera) {\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\n        const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n        const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\n        maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n        tick = maxLength / 20;\n        size = maxLength * multiplier;\n        divisions = size / tick;\n      }\n\n      if (this._grid == null) {\n        this._grid = new GridHelper(size, divisions, color, color);\n\n        this._grid.position.copy(this._gizmos.position);\n\n        this._gridPosition.copy(this._grid.position);\n\n        this._grid.quaternion.copy(this.camera.quaternion);\n\n        this._grid.rotateX(Math.PI * 0.5);\n\n        this.scene.add(this._grid);\n      }\n    }\n  };\n  /**\n   * Remove all listeners, stop animations and clean scene\n   */\n\n  dispose = () => {\n    if (this._animationId != -1) {\n      window.cancelAnimationFrame(this._animationId);\n    }\n\n    this.domElement.removeEventListener('pointerdown', this.onPointerDown);\n    this.domElement.removeEventListener('pointercancel', this.onPointerCancel);\n    this.domElement.removeEventListener('wheel', this.onWheel);\n    this.domElement.removeEventListener('contextmenu', this.onContextMenu);\n    window.removeEventListener('pointermove', this.onPointerMove);\n    window.removeEventListener('pointerup', this.onPointerUp);\n    window.removeEventListener('resize', this.onWindowResize);\n    if (this.scene !== null) this.scene.remove(this._gizmos);\n    this.disposeGrid();\n  };\n  /**\n   * remove the grid from the scene\n   */\n\n  disposeGrid = () => {\n    if (this._grid != null && this.scene != null) {\n      this.scene.remove(this._grid);\n      this._grid = null;\n    }\n  };\n  /**\n   * Compute the easing out cubic function for ease out effect in animation\n   * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n   * @returns {Number} Result of easing out cubic at time t\n   */\n\n  easeOutCubic = t => {\n    return 1 - Math.pow(1 - t, 3);\n  };\n  /**\n   * Make rotation gizmos more or less visible\n   * @param {Boolean} isActive If true, make gizmos more visible\n   */\n\n  activateGizmos = isActive => {\n    const gizmoX = this._gizmos.children[0];\n    const gizmoY = this._gizmos.children[1];\n    const gizmoZ = this._gizmos.children[2];\n\n    if (isActive) {\n      gizmoX.material.setValues({\n        opacity: 1\n      });\n      gizmoY.material.setValues({\n        opacity: 1\n      });\n      gizmoZ.material.setValues({\n        opacity: 1\n      });\n    } else {\n      gizmoX.material.setValues({\n        opacity: 0.6\n      });\n      gizmoY.material.setValues({\n        opacity: 0.6\n      });\n      gizmoZ.material.setValues({\n        opacity: 0.6\n      });\n    }\n  };\n  /**\n   * Calculate the cursor position in NDC\n   * @param {number} x Cursor horizontal coordinate within the canvas\n   * @param {number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor normalized position inside the canvas\n   */\n\n  getCursorNDC = (cursorX, cursorY, canvas) => {\n    const canvasRect = canvas.getBoundingClientRect();\n\n    this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n\n    this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n\n    return this._v2_1.clone();\n  };\n  /**\n   * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n   * @param {Number} x Cursor horizontal coordinate within the canvas\n   * @param {Number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor position inside the canvas\n   */\n\n  getCursorPosition = (cursorX, cursorY, canvas) => {\n    this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n    this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\n    this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\n    return this._v2_1.clone();\n  };\n  /**\n   * Set the camera to be controlled\n   * @param {Camera} camera The virtual camera to be controlled\n   */\n\n  setCamera = camera => {\n    camera.lookAt(this.target);\n    camera.updateMatrix(); //setting state\n\n    if (camera.type == 'PerspectiveCamera') {\n      this._fov0 = camera.fov;\n      this._fovState = camera.fov;\n    }\n\n    this._cameraMatrixState0.copy(camera.matrix);\n\n    this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n    this._cameraProjectionState.copy(camera.projectionMatrix);\n\n    this._zoom0 = camera.zoom;\n    this._zoomState = this._zoom0;\n    this._initialNear = camera.near;\n    this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n    this._nearPos = this._initialNear;\n    this._initialFar = camera.far;\n    this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n    this._farPos = this._initialFar;\n\n    this._up0.copy(camera.up);\n\n    this._upState.copy(camera.up);\n\n    this.camera = camera;\n    this.camera.updateProjectionMatrix(); //making gizmos\n\n    this._tbRadius = this.calculateTbRadius(camera);\n    this.makeGizmos(this.target, this._tbRadius);\n  };\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n  /**\n   * Set gizmos radius factor and redraws gizmos\n   * @param {Float} value Value of radius factor\n   */\n\n\n  setTbRadius(value) {\n    this.radiusFactor = value;\n    this._tbRadius = this.calculateTbRadius(this.camera);\n    const curve = new EllipseCurve(0, 0, this._tbRadius, this._tbRadius);\n    const points = curve.getPoints(this._curvePts);\n    const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n    for (const gizmo in this._gizmos.children) {\n      this._gizmos.children[gizmo].geometry = curveGeometry;\n    }\n\n    this.dispatchEvent(_changeEvent);\n  }\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n\n\n  makeGizmos = (tbCenter, tbRadius) => {\n    const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n    const points = curve.getPoints(this._curvePts); //geometry\n\n    const curveGeometry = new BufferGeometry().setFromPoints(points); //material\n\n    const curveMaterialX = new LineBasicMaterial({\n      color: 0xff8080,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n    const curveMaterialY = new LineBasicMaterial({\n      color: 0x80ff80,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n    const curveMaterialZ = new LineBasicMaterial({\n      color: 0x8080ff,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    }); //line\n\n    const gizmoX = new Line(curveGeometry, curveMaterialX);\n    const gizmoY = new Line(curveGeometry, curveMaterialY);\n    const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n    const rotation = Math.PI * 0.5;\n    gizmoX.rotation.x = rotation;\n    gizmoY.rotation.y = rotation; //setting state\n\n    this._gizmoMatrixState0.identity().setPosition(tbCenter);\n\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n    if (this.camera.zoom !== 1) {\n      //adapt gizmos size to camera zoom\n      const size = 1 / this.camera.zoom;\n\n      this._scaleMatrix.makeScale(size, size, size);\n\n      this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n\n      this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n\n      this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n\n      this._gizmoMatrixState.premultiply(this._translationMatrix);\n    }\n\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale); //\n\n\n    this._gizmos.traverse(function (object) {\n      if (object.isLine) {\n        object.geometry.dispose();\n        object.material.dispose();\n      }\n    });\n\n    this._gizmos.clear(); //\n\n\n    this._gizmos.add(gizmoX);\n\n    this._gizmos.add(gizmoY);\n\n    this._gizmos.add(gizmoZ);\n  };\n  /**\n   * Perform animation for focus operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} point Point of interest for focus operation\n   * @param {Matrix4} cameraMatrix Camera matrix\n   * @param {Matrix4} gizmoMatrix Gizmos matrix\n   */\n\n  onFocusAnim = (time, point, cameraMatrix, gizmoMatrix) => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._timeStart = time;\n    }\n\n    if (this._state == STATE.ANIMATION_FOCUS) {\n      const deltaTime = time - this._timeStart;\n      const animTime = deltaTime / this.focusAnimationTime;\n\n      this._gizmoMatrixState.copy(gizmoMatrix);\n\n      if (animTime >= 1) {\n        //animation end\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        this.focus(point, this.scaleFactor);\n        this._timeStart = -1;\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      } else {\n        const amount = this.easeOutCubic(animTime);\n        const size = 1 - amount + this.scaleFactor * amount;\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        this.focus(point, size, amount);\n        this.dispatchEvent(_changeEvent);\n        const self = this;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n        });\n      }\n    } else {\n      //interrupt animation\n      this._animationId = -1;\n      this._timeStart = -1;\n    }\n  };\n  /**\n   * Perform animation for rotation operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} rotationAxis Rotation axis\n   * @param {number} w0 Initial angular velocity\n   */\n\n  onRotationAnim = (time, rotationAxis, w0) => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._anglePrev = 0;\n      this._angleCurrent = 0;\n      this._timeStart = time;\n    }\n\n    if (this._state == STATE.ANIMATION_ROTATE) {\n      //w = w0 + alpha * t\n      const deltaTime = (time - this._timeStart) / 1000;\n      const w = w0 + -this.dampingFactor * deltaTime;\n\n      if (w > 0) {\n        //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n        this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n        this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n        this.dispatchEvent(_changeEvent);\n        const self = this;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onRotationAnim(t, rotationAxis, w0);\n        });\n      } else {\n        this._animationId = -1;\n        this._timeStart = -1;\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    } else {\n      //interrupt animation\n      this._animationId = -1;\n      this._timeStart = -1;\n\n      if (this._state != STATE.ROTATE) {\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    }\n  };\n  /**\n   * Perform pan operation moving camera between two points\n   * @param {Vector3} p0 Initial point\n   * @param {Vector3} p1 Ending point\n   * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n   */\n\n  pan = (() => {\n    var _this4 = this;\n\n    return function (p0, p1) {\n      let adjust = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const movement = p0.clone().sub(p1);\n\n      if (_this4.camera.isOrthographicCamera) {\n        //adjust movement amount\n        movement.multiplyScalar(1 / _this4.camera.zoom);\n      } else if (_this4.camera.isPerspectiveCamera && adjust) {\n        //adjust movement amount\n        _this4._v3_1.setFromMatrixPosition(_this4._cameraMatrixState0); //camera's initial position\n\n\n        _this4._v3_2.setFromMatrixPosition(_this4._gizmoMatrixState0); //gizmo's initial position\n\n\n        const distanceFactor = _this4._v3_1.distanceTo(_this4._v3_2) / _this4.camera.position.distanceTo(_this4._gizmos.position);\n\n        movement.multiplyScalar(1 / distanceFactor);\n      }\n\n      _this4._v3_1.set(movement.x, movement.y, 0).applyQuaternion(_this4.camera.quaternion);\n\n      _this4._m4_1.makeTranslation(_this4._v3_1.x, _this4._v3_1.y, _this4._v3_1.z);\n\n      _this4.setTransformationMatrices(_this4._m4_1, _this4._m4_1);\n\n      return _transformation;\n    };\n  })();\n  /**\n   * Reset trackball\n   */\n\n  reset = () => {\n    this.camera.zoom = this._zoom0;\n\n    if (this.camera.isPerspectiveCamera) {\n      this.camera.fov = this._fov0;\n    }\n\n    this.camera.near = this._nearPos;\n    this.camera.far = this._farPos;\n\n    this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n    this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n    this.camera.up.copy(this._up0);\n    this.camera.updateMatrix();\n    this.camera.updateProjectionMatrix();\n\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n    this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n    this._gizmos.updateMatrix();\n\n    this._tbRadius = this.calculateTbRadius(this.camera);\n    this.makeGizmos(this._gizmos.position, this._tbRadius);\n    this.camera.lookAt(this._gizmos.position);\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_changeEvent);\n  };\n  /**\n   * Rotate the camera around an axis passing by trackball's center\n   * @param {Vector3} axis Rotation axis\n   * @param {number} angle Angle in radians\n   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n   */\n\n  rotate = (axis, angle) => {\n    const point = this._gizmos.position; //rotation center\n\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n    this._rotationMatrix.makeRotationAxis(axis, -angle); //rotate camera\n\n\n    this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n    this._m4_1.multiply(this._rotationMatrix);\n\n    this._m4_1.multiply(this._translationMatrix);\n\n    this.setTransformationMatrices(this._m4_1);\n    return _transformation;\n  };\n  copyState = () => {\n    let state;\n\n    if (this.camera.isOrthographicCamera) {\n      state = JSON.stringify({\n        arcballState: {\n          cameraFar: this.camera.far,\n          cameraMatrix: this.camera.matrix,\n          cameraNear: this.camera.near,\n          cameraUp: this.camera.up,\n          cameraZoom: this.camera.zoom,\n          gizmoMatrix: this._gizmos.matrix\n        }\n      });\n    } else if (this.camera.isPerspectiveCamera) {\n      state = JSON.stringify({\n        arcballState: {\n          cameraFar: this.camera.far,\n          cameraFov: this.camera.fov,\n          cameraMatrix: this.camera.matrix,\n          cameraNear: this.camera.near,\n          cameraUp: this.camera.up,\n          cameraZoom: this.camera.zoom,\n          gizmoMatrix: this._gizmos.matrix\n        }\n      });\n    }\n\n    navigator.clipboard.writeText(state);\n  };\n  pasteState = () => {\n    const self = this;\n    navigator.clipboard.readText().then(function resolved(value) {\n      self.setStateFromJSON(value);\n    });\n  };\n  /**\n   * Save the current state of the control. This can later be recover with .reset\n   */\n\n  saveState = () => {\n    this._cameraMatrixState0.copy(this.camera.matrix);\n\n    this._gizmoMatrixState0.copy(this._gizmos.matrix);\n\n    this._nearPos = this.camera.near;\n    this._farPos = this.camera.far;\n    this._zoom0 = this.camera.zoom;\n\n    this._up0.copy(this.camera.up);\n\n    if (this.camera.isPerspectiveCamera) {\n      this._fov0 = this.camera.fov;\n    }\n  };\n  /**\n   * Perform uniform scale operation around a given point\n   * @param {Number} size Scale factor\n   * @param {Vector3} point Point around which scale\n   * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n   */\n\n  scale = (() => {\n    var _this5 = this;\n\n    return function (size, point) {\n      let scaleGizmos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      _scalePointTemp.copy(point);\n\n      let sizeInverse = 1 / size;\n\n      if (_this5.camera.isOrthographicCamera) {\n        //camera zoom\n        _this5.camera.zoom = _this5._zoomState;\n        _this5.camera.zoom *= size; //check min and max zoom\n\n        if (_this5.camera.zoom > _this5.maxZoom) {\n          _this5.camera.zoom = _this5.maxZoom;\n          sizeInverse = _this5._zoomState / _this5.maxZoom;\n        } else if (_this5.camera.zoom < _this5.minZoom) {\n          _this5.camera.zoom = _this5.minZoom;\n          sizeInverse = _this5._zoomState / _this5.minZoom;\n        }\n\n        _this5.camera.updateProjectionMatrix();\n\n        _this5._v3_1.setFromMatrixPosition(_this5._gizmoMatrixState); //gizmos position\n        //scale gizmos so they appear in the same spot having the same dimension\n\n\n        _this5._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n        _this5._translationMatrix.makeTranslation(-_this5._v3_1.x, -_this5._v3_1.y, -_this5._v3_1.z);\n\n        _this5._m4_2.makeTranslation(_this5._v3_1.x, _this5._v3_1.y, _this5._v3_1.z).multiply(_this5._scaleMatrix);\n\n        _this5._m4_2.multiply(_this5._translationMatrix); //move camera and gizmos to obtain pinch effect\n\n\n        _scalePointTemp.sub(_this5._v3_1);\n\n        const amount = _scalePointTemp.clone().multiplyScalar(sizeInverse);\n\n        _scalePointTemp.sub(amount);\n\n        _this5._m4_1.makeTranslation(_scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z);\n\n        _this5._m4_2.premultiply(_this5._m4_1);\n\n        _this5.setTransformationMatrices(_this5._m4_1, _this5._m4_2);\n\n        return _transformation;\n      } else if (_this5.camera.isPerspectiveCamera) {\n        _this5._v3_1.setFromMatrixPosition(_this5._cameraMatrixState);\n\n        _this5._v3_2.setFromMatrixPosition(_this5._gizmoMatrixState); //move camera\n\n\n        let distance = _this5._v3_1.distanceTo(_scalePointTemp);\n\n        let amount = distance - distance * sizeInverse; //check min and max distance\n\n        const newDistance = distance - amount;\n\n        if (newDistance < _this5.minDistance) {\n          sizeInverse = _this5.minDistance / distance;\n          amount = distance - distance * sizeInverse;\n        } else if (newDistance > _this5.maxDistance) {\n          sizeInverse = _this5.maxDistance / distance;\n          amount = distance - distance * sizeInverse;\n        }\n\n        _offset.copy(_scalePointTemp).sub(_this5._v3_1).normalize().multiplyScalar(amount);\n\n        _this5._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n\n        if (scaleGizmos) {\n          //scale gizmos so they appear in the same spot having the same dimension\n          const pos = _this5._v3_2;\n          distance = pos.distanceTo(_scalePointTemp);\n          amount = distance - distance * sizeInverse;\n\n          _offset.copy(_scalePointTemp).sub(_this5._v3_2).normalize().multiplyScalar(amount);\n\n          _this5._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n\n          _this5._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n          _this5._m4_2.makeTranslation(_offset.x, _offset.y, _offset.z).multiply(_this5._translationMatrix);\n\n          _this5._m4_2.multiply(_this5._scaleMatrix);\n\n          _this5._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n\n          _this5._m4_2.multiply(_this5._translationMatrix);\n\n          _this5.setTransformationMatrices(_this5._m4_1, _this5._m4_2);\n        } else {\n          _this5.setTransformationMatrices(_this5._m4_1);\n        }\n\n        return _transformation;\n      }\n    };\n  })();\n  /**\n   * Set camera fov\n   * @param {Number} value fov to be setted\n   */\n\n  setFov = value => {\n    if (this.camera.isPerspectiveCamera) {\n      this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n      this.camera.updateProjectionMatrix();\n    }\n  };\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n\n  setTransformationMatrices() {\n    let camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let gizmos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (camera != null) {\n      if (_transformation.camera != null) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n\n    if (gizmos != null) {\n      if (_transformation.gizmos != null) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n\n\n  zRotate = (point, angle) => {\n    this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n    this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n    this._m4_1.multiply(this._rotationMatrix);\n\n    this._m4_1.multiply(this._translationMatrix);\n\n    this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\n\n\n    this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\n\n\n    this._v3_2.sub(this._v3_1);\n\n    this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n\n    this.setTransformationMatrices(this._m4_1, this._m4_2);\n    return _transformation;\n  };\n\n  getRaycaster() {\n    return _raycaster;\n  }\n  /**\n   * Unproject the cursor on the 3D object surface\n   * @param {Vector2} cursor Cursor coordinates in NDC\n   * @param {Camera} camera Virtual camera\n   * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n   */\n\n\n  unprojectOnObj = (cursor, camera) => {\n    const raycaster = this.getRaycaster();\n    raycaster.near = camera.near;\n    raycaster.far = camera.far;\n    raycaster.setFromCamera(cursor, camera);\n    const intersect = raycaster.intersectObjects(this.scene.children, true);\n\n    for (let i = 0; i < intersect.length; i++) {\n      if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face != null) {\n        return intersect[i].point.clone();\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Unproject the cursor on the trackball surface\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {number} tbRadius The trackball radius\n   * @returns {Vector3} The unprojected point on the trackball surface\n   */\n\n  unprojectOnTbSurface = (camera, cursorX, cursorY, canvas, tbRadius) => {\n    if (camera.type == 'OrthographicCamera') {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n\n      const x2 = Math.pow(this._v2_1.x, 2);\n      const y2 = Math.pow(this._v2_1.y, 2);\n      const r2 = Math.pow(this._tbRadius, 2);\n\n      if (x2 + y2 <= r2 * 0.5) {\n        //intersection with sphere\n        this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n      } else {\n        //intersection with hyperboloid\n        this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n      }\n\n      return this._v3_1;\n    } else if (camera.type == 'PerspectiveCamera') {\n      //unproject cursor on the near plane\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n      const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\n      const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n      const radius2 = Math.pow(tbRadius, 2); //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z;\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n        return rayDir;\n      }\n\n      const m = h / l;\n      const q = cameraGizmoDistance;\n      /*\n       * calculate intersection point between unprojected ray and trackball surface\n       *|y = m * x + q\n       *|x^2 + y^2 = r^2\n       *\n       * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n       */\n\n      let a = Math.pow(m, 2) + 1;\n      let b = 2 * m * q;\n      let c = Math.pow(q, 2) - radius2;\n      let delta = Math.pow(b, 2) - 4 * a * c;\n\n      if (delta >= 0) {\n        //intersection with sphere\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n        this._v2_1.setY(m * this._v2_1.x + q);\n\n        const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n        if (angle >= 45) {\n          //if angle between intersection point and X' axis is >= 45°, return that point\n          //otherwise, calculate intersection point with hyperboloid\n          const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n          rayDir.multiplyScalar(rayLength);\n          rayDir.z += cameraGizmoDistance;\n          return rayDir;\n        }\n      } //intersection with hyperboloid\n\n      /*\n       *|y = m * x + q\n       *|y = (1 / x) * (r^2 / 2)\n       *\n       * m * x^2 + q * x - r^2 / 2 = 0\n       */\n\n\n      a = m;\n      b = q;\n      c = -radius2 * 0.5;\n      delta = Math.pow(b, 2) - 4 * a * c;\n\n      this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n      this._v2_1.setY(m * this._v2_1.x + q);\n\n      const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n      rayDir.multiplyScalar(rayLength);\n      rayDir.z += cameraGizmoDistance;\n      return rayDir;\n    }\n  };\n  /**\n   * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n   * @returns {Vector3} The unprojected point on the trackball plane\n   */\n\n  unprojectOnTbPlane = (() => {\n    var _this6 = this;\n\n    return function (camera, cursorX, cursorY, canvas) {\n      let initialDistance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      if (camera.type == 'OrthographicCamera') {\n        _this6._v2_1.copy(_this6.getCursorPosition(cursorX, cursorY, canvas));\n\n        _this6._v3_1.set(_this6._v2_1.x, _this6._v2_1.y, 0);\n\n        return _this6._v3_1.clone();\n      } else if (camera.type == 'PerspectiveCamera') {\n        _this6._v2_1.copy(_this6.getCursorNDC(cursorX, cursorY, canvas)); //unproject cursor on the near plane\n\n\n        _this6._v3_1.set(_this6._v2_1.x, _this6._v2_1.y, -1);\n\n        _this6._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = _this6._v3_1.clone().normalize(); //unprojected ray direction\n        //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n\n        const h = _this6._v3_1.z;\n        const l = Math.sqrt(Math.pow(_this6._v3_1.x, 2) + Math.pow(_this6._v3_1.y, 2));\n        let cameraGizmoDistance;\n\n        if (initialDistance) {\n          cameraGizmoDistance = _this6._v3_1.setFromMatrixPosition(_this6._cameraMatrixState0).distanceTo(_this6._v3_2.setFromMatrixPosition(_this6._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(_this6._gizmos.position);\n        }\n        /*\n         * calculate intersection point between unprojected ray and the plane\n         *|y = mx + q\n         *|y = 0\n         *\n         * x = -q/m\n        */\n\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        const x = -q / m;\n        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    };\n  })();\n  /**\n   * Update camera and gizmos state\n   */\n\n  updateMatrixState = () => {\n    //update camera and gizmos state\n    this._cameraMatrixState.copy(this.camera.matrix);\n\n    this._gizmoMatrixState.copy(this._gizmos.matrix);\n\n    if (this.camera.isOrthographicCamera) {\n      this._cameraProjectionState.copy(this.camera.projectionMatrix);\n\n      this.camera.updateProjectionMatrix();\n      this._zoomState = this.camera.zoom;\n    } else if (this.camera.isPerspectiveCamera) {\n      this._fovState = this.camera.fov;\n    }\n  };\n  /**\n   * Update the trackball FSA\n   * @param {STATE} newState New state of the FSA\n   * @param {Boolean} updateMatrices If matriices state should be updated\n   */\n\n  updateTbState = (newState, updateMatrices) => {\n    this._state = newState;\n\n    if (updateMatrices) {\n      this.updateMatrixState();\n    }\n  };\n  update = () => {\n    const EPS = 0.000001;\n\n    if (this.target.equals(this._currentTarget) === false) {\n      this._gizmos.position.copy(this.target); //for correct radius calculation\n\n\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      this.makeGizmos(this.target, this._tbRadius);\n\n      this._currentTarget.copy(this.target);\n    } //check min/max parameters\n\n\n    if (this.camera.isOrthographicCamera) {\n      //check zoom\n      if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n        const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\n        this.applyTransformMatrix(this.scale(newZoom / this.camera.zoom, this._gizmos.position, true));\n      }\n    } else if (this.camera.isPerspectiveCamera) {\n      //check distance\n      const distance = this.camera.position.distanceTo(this._gizmos.position);\n\n      if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n        const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n        this.applyTransformMatrix(this.scale(newDistance / distance, this._gizmos.position));\n        this.updateMatrixState();\n      } //check fov\n\n\n      if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n        this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\n        this.camera.updateProjectionMatrix();\n      }\n\n      const oldRadius = this._tbRadius;\n      this._tbRadius = this.calculateTbRadius(this.camera);\n\n      if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n        const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n        const newRadius = this._tbRadius / scale;\n        const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n        const points = curve.getPoints(this._curvePts);\n        const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n        for (const gizmo in this._gizmos.children) {\n          this._gizmos.children[gizmo].geometry = curveGeometry;\n        }\n      }\n    }\n\n    this.camera.lookAt(this._gizmos.position);\n  };\n  setStateFromJSON = json => {\n    const state = JSON.parse(json);\n\n    if (state.arcballState != undefined) {\n      this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.up.copy(state.arcballState.cameraUp);\n      this.camera.near = state.arcballState.cameraNear;\n      this.camera.far = state.arcballState.cameraFar;\n      this.camera.zoom = state.arcballState.cameraZoom;\n\n      if (this.camera.isPerspectiveCamera) {\n        this.camera.fov = state.arcballState.cameraFov;\n      }\n\n      this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this.camera.updateMatrix();\n      this.camera.updateProjectionMatrix();\n\n      this._gizmos.updateMatrix();\n\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n      this.makeGizmos(this._gizmos.position, this._tbRadius);\n\n      this._gizmoMatrixState0.copy(gizmoTmp);\n\n      this.camera.lookAt(this._gizmos.position);\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_changeEvent);\n    }\n  };\n}\n\nexport { ArcballControls };","map":{"version":3,"names":["GridHelper","EllipseCurve","BufferGeometry","Line","LineBasicMaterial","Raycaster","Group","Box3","Sphere","Quaternion","Vector2","Vector3","Matrix4","MathUtils","EventDispatcher","STATE","IDLE","Symbol","ROTATE","PAN","SCALE","FOV","FOCUS","ZROTATE","TOUCH_MULTI","ANIMATION_FOCUS","ANIMATION_ROTATE","INPUT","NONE","ONE_FINGER","ONE_FINGER_SWITCHED","TWO_FINGER","MULT_FINGER","CURSOR","_center","x","y","_transformation","camera","gizmos","_changeEvent","type","_startEvent","_endEvent","_raycaster","_offset","_gizmoMatrixStateTemp","_cameraMatrixStateTemp","_scalePointTemp","ArcballControls","constructor","domElement","scene","target","_currentTarget","radiusFactor","mouseActions","_mouseOp","_v2_1","_v3_1","_v3_2","_m4_1","_m4_2","_quat","_translationMatrix","_rotationMatrix","_scaleMatrix","_rotationAxis","_cameraMatrixState","_cameraProjectionState","_fovState","_upState","_zoomState","_nearPos","_farPos","_gizmoMatrixState","_up0","_zoom0","_fov0","_initialNear","_nearPos0","_initialFar","_farPos0","_cameraMatrixState0","_gizmoMatrixState0","_button","_touchStart","_touchCurrent","_input","_switchSensibility","_startFingerDistance","_currentFingerDistance","_startFingerRotation","_currentFingerRotation","_devPxRatio","_downValid","_nclicks","_downEvents","_downStart","_clickStart","_maxDownTime","_maxInterval","_posThreshold","_movementThreshold","_currentCursorPosition","_startCursorPosition","_grid","_gridPosition","_gizmos","_curvePts","_timeStart","_animationId","focusAnimationTime","_timePrev","_timeCurrent","_anglePrev","_angleCurrent","_cursorPosPrev","_cursorPosCurr","_wPrev","_wCurr","adjustNearFar","scaleFactor","dampingFactor","wMax","enableAnimations","enableGrid","cursorZoom","minFov","maxFov","enabled","enablePan","enableRotate","enableZoom","enableGizmos","minDistance","maxDistance","Infinity","minZoom","maxZoom","_tbRadius","_state","setCamera","add","style","touchAction","window","devicePixelRatio","initializeMouseActions","addEventListener","onContextMenu","onWheel","onPointerDown","onPointerCancel","onWindowResize","scale","z","calculateTbRadius","newRadius","curve","points","getPoints","curveGeometry","setFromPoints","gizmo","children","geometry","dispatchEvent","event","i","length","mouse","preventDefault","splice","button","isPrimary","push","performance","now","pointerType","onSinglePanStart","onPointerMove","onPointerUp","onRotateStart","onPinchStart","onDoublePanStart","onTriplePanStart","modifier","ctrlKey","metaKey","shiftKey","getOpFromAction","updateTouchEvent","onSinglePanMove","movement","calculatePointersDistance","onRotateMove","onPinchMove","onDoublePanMove","onTriplePanMove","mouseOpState","getOpStateFromAction","nTouch","pointerId","removeEventListener","onSinglePanEnd","onDoublePanEnd","onPinchEnd","onRotateEnd","onTriplePanEnd","downTime","timeStamp","clickInterval","onDoubleTap","shift","mouseOp","notchDeltaY","sgn","deltaY","size","updateTbState","Math","pow","scalePoint","isOrthographicCamera","unprojectOnTbPlane","clientX","clientY","applyQuaternion","quaternion","multiplyScalar","zoom","position","isPerspectiveCamera","applyTransformMatrix","disposeGrid","drawGrid","deltaX","setFromMatrixPosition","distanceTo","xNew","clamp","tan","DEG2RAD","fov","newFov","RAD2DEG","atan","newDistance","setFov","operation","setCenter","cancelAnimationFrame","activateGizmos","copy","unprojectOnTbSurface","setY","getCursorNDC","opState","restart","pan","distance","angle","angleTo","amount","max","rotate","calculateRotationAxis","calculateAngularSpeed","screenNotches","sub","normalize","makeTranslation","deltaTime","w","abs","self","requestAnimationFrame","t","rotationAxis","onRotationAnim","min","hitP","unprojectOnObj","onFocusAnim","focus","getAngle","getWorldDirection","rotationPoint","zRotate","nFingers","setMouseAction","compareMouseAction","action1","action2","key","operationInput","mouseInput","keyInput","state","includes","action","unsetMouseAction","p1","p2","atan2","PI","transformation","premultiply","decompose","updateMatrix","up","cameraDistance","bb","setFromObject","sphere","getBoundingSphere","adjustedNearPosition","radius","center","regularNearPosition","minNearPos","near","adjustedFarPosition","regularFarPosition","minFarPos","far","updateProjectionMatrix","update","p0","t0","t1","s","sqrt","vec1","vec2","extractRotation","setFromRotationMatrix","crossVectors","clone","halfFovV","halfFovH","aspect","top","right","point","color","multiplier","divisions","maxLength","tick","width","left","height","bottom","rotateX","dispose","remove","easeOutCubic","isActive","gizmoX","gizmoY","gizmoZ","material","setValues","opacity","cursorX","cursorY","canvas","canvasRect","getBoundingClientRect","setX","getCursorPosition","lookAt","matrix","projectionMatrix","makeGizmos","setGizmosVisible","value","visible","setTbRadius","tbCenter","tbRadius","curveMaterialX","fog","transparent","curveMaterialY","curveMaterialZ","rotation","identity","setPosition","makeScale","traverse","object","isLine","clear","time","cameraMatrix","gizmoMatrix","animTime","w0","adjust","distanceFactor","set","setTransformationMatrices","reset","axis","makeRotationAxis","multiply","copyState","JSON","stringify","arcballState","cameraFar","cameraNear","cameraUp","cameraZoom","cameraFov","navigator","clipboard","writeText","pasteState","readText","then","resolved","setStateFromJSON","saveState","scaleGizmos","sizeInverse","pos","applyAxisAngle","getRaycaster","cursor","raycaster","setFromCamera","intersect","intersectObjects","uuid","face","x2","y2","r2","setZ","applyMatrix4","projectionMatrixInverse","rayDir","cameraGizmoDistance","radius2","h","l","m","q","a","b","c","delta","rayLength","initialDistance","updateMatrixState","newState","updateMatrices","EPS","equals","newZoom","oldRadius","json","parse","undefined","fromArray","elements","gizmoTmp"],"sources":["/home/mackgrissom/code/MackGrissom/react3fiber/first-r3f/node_modules/three/examples/jsm/controls/ArcballControls.js"],"sourcesContent":["import {\n\tGridHelper,\n\tEllipseCurve,\n\tBufferGeometry,\n\tLine,\n\tLineBasicMaterial,\n\tRaycaster,\n\tGroup,\n\tBox3,\n\tSphere,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMatrix4,\n\tMathUtils,\n\tEventDispatcher\n} from 'three';\n\n//trackball state\nconst STATE = {\n\n\tIDLE: Symbol(),\n\tROTATE: Symbol(),\n\tPAN: Symbol(),\n\tSCALE: Symbol(),\n\tFOV: Symbol(),\n\tFOCUS: Symbol(),\n\tZROTATE: Symbol(),\n\tTOUCH_MULTI: Symbol(),\n\tANIMATION_FOCUS: Symbol(),\n\tANIMATION_ROTATE: Symbol()\n\n};\n\nconst INPUT = {\n\n\tNONE: Symbol(),\n\tONE_FINGER: Symbol(),\n\tONE_FINGER_SWITCHED: Symbol(),\n\tTWO_FINGER: Symbol(),\n\tMULT_FINGER: Symbol(),\n\tCURSOR: Symbol()\n\n};\n\n//cursor center coordinates\nconst _center = {\n\n\tx: 0,\n\ty: 0\n\n};\n\n//transformation matrices for gizmos and camera\nconst _transformation = {\n\n\tcamera: new Matrix4(),\n\tgizmos: new Matrix4()\n\n};\n\n//events\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nconst _raycaster = new Raycaster();\nconst _offset = new Vector3();\n\nconst _gizmoMatrixStateTemp = new Matrix4();\nconst _cameraMatrixStateTemp = new Matrix4();\nconst _scalePointTemp = new Vector3();\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\nclass ArcballControls extends EventDispatcher {\n\n\tconstructor( camera, domElement, scene = null ) {\n\n\t\tsuper();\n\t\tthis.camera = null;\n\t\tthis.domElement = domElement;\n\t\tthis.scene = scene;\n\t\tthis.target = new Vector3();\n\t\tthis._currentTarget = new Vector3();\n\t\tthis.radiusFactor = 0.67;\n\n\t\tthis.mouseActions = [];\n\t\tthis._mouseOp = null;\n\n\n\t\t//global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\t\tthis._v2_1 = new Vector2();\n\t\tthis._v3_1 = new Vector3();\n\t\tthis._v3_2 = new Vector3();\n\n\t\tthis._m4_1 = new Matrix4();\n\t\tthis._m4_2 = new Matrix4();\n\n\t\tthis._quat = new Quaternion();\n\n\t\t//transformation matrices\n\t\tthis._translationMatrix = new Matrix4(); //matrix for translation operation\n\t\tthis._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\t\tthis._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n\t\tthis._rotationAxis = new Vector3(); //axis for rotate operation\n\n\n\t\t//camera state\n\t\tthis._cameraMatrixState = new Matrix4();\n\t\tthis._cameraProjectionState = new Matrix4();\n\n\t\tthis._fovState = 1;\n\t\tthis._upState = new Vector3();\n\t\tthis._zoomState = 1;\n\t\tthis._nearPos = 0;\n\t\tthis._farPos = 0;\n\n\t\tthis._gizmoMatrixState = new Matrix4();\n\n\t\t//initial values\n\t\tthis._up0 = new Vector3();\n\t\tthis._zoom0 = 1;\n\t\tthis._fov0 = 0;\n\t\tthis._initialNear = 0;\n\t\tthis._nearPos0 = 0;\n\t\tthis._initialFar = 0;\n\t\tthis._farPos0 = 0;\n\t\tthis._cameraMatrixState0 = new Matrix4();\n\t\tthis._gizmoMatrixState0 = new Matrix4();\n\n\t\t//pointers array\n\t\tthis._button = - 1;\n\t\tthis._touchStart = [];\n\t\tthis._touchCurrent = [];\n\t\tthis._input = INPUT.NONE;\n\n\t\t//two fingers touch interaction\n\t\tthis._switchSensibility = 32;\t//minimum movement to be performed to fire single pan start after the second finger has been released\n\t\tthis._startFingerDistance = 0; //distance between two fingers\n\t\tthis._currentFingerDistance = 0;\n\t\tthis._startFingerRotation = 0; //amount of rotation performed with two fingers\n\t\tthis._currentFingerRotation = 0;\n\n\t\t//double tap\n\t\tthis._devPxRatio = 0;\n\t\tthis._downValid = true;\n\t\tthis._nclicks = 0;\n\t\tthis._downEvents = [];\n\t\tthis._downStart = 0;\t//pointerDown time\n\t\tthis._clickStart = 0;\t//first click time\n\t\tthis._maxDownTime = 250;\n\t\tthis._maxInterval = 300;\n\t\tthis._posThreshold = 24;\n\t\tthis._movementThreshold = 24;\n\n\t\t//cursor positions\n\t\tthis._currentCursorPosition = new Vector3();\n\t\tthis._startCursorPosition = new Vector3();\n\n\t\t//grid\n\t\tthis._grid = null; //grid to be visualized during pan operation\n\t\tthis._gridPosition = new Vector3();\n\n\t\t//gizmos\n\t\tthis._gizmos = new Group();\n\t\tthis._curvePts = 128;\n\n\n\t\t//animations\n\t\tthis._timeStart = - 1; //initial time\n\t\tthis._animationId = - 1;\n\n\t\t//focus animation\n\t\tthis.focusAnimationTime = 500; //duration of focus animation in ms\n\n\t\t//rotate animation\n\t\tthis._timePrev = 0; //time at which previous rotate operation has been detected\n\t\tthis._timeCurrent = 0; //time at which current rotate operation has been detected\n\t\tthis._anglePrev = 0; //angle of previous rotation\n\t\tthis._angleCurrent = 0; //angle of current rotation\n\t\tthis._cursorPosPrev = new Vector3();\t//cursor position when previous rotate operation has been detected\n\t\tthis._cursorPosCurr = new Vector3();//cursor position when current rotate operation has been detected\n\t\tthis._wPrev = 0; //angular velocity of the previous rotate operation\n\t\tthis._wCurr = 0; //angular velocity of the current rotate operation\n\n\n\t\t//parameters\n\t\tthis.adjustNearFar = false;\n\t\tthis.scaleFactor = 1.1;\t//zoom/distance multiplier\n\t\tthis.dampingFactor = 25;\n\t\tthis.wMax = 20;\t//maximum angular velocity allowed\n\t\tthis.enableAnimations = true; //if animations should be performed\n\t\tthis.enableGrid = false; //if grid should be showed during pan operation\n\t\tthis.cursorZoom = false;\t//if wheel zoom should be cursor centered\n\t\tthis.minFov = 5;\n\t\tthis.maxFov = 90;\n\n\t\tthis.enabled = true;\n\t\tthis.enablePan = true;\n\t\tthis.enableRotate = true;\n\t\tthis.enableZoom = true;\n\t\tthis.enableGizmos = true;\n\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t//trackball parameters\n\t\tthis._tbRadius = 1;\n\n\t\t//FSA\n\t\tthis._state = STATE.IDLE;\n\n\t\tthis.setCamera( camera );\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tthis.scene.add( this._gizmos );\n\n\t\t}\n\n\t\tthis.domElement.style.touchAction = 'none';\n\t\tthis._devPxRatio = window.devicePixelRatio;\n\n\t\tthis.initializeMouseActions();\n\n\t\tthis.domElement.addEventListener( 'contextmenu', this.onContextMenu );\n\t\tthis.domElement.addEventListener( 'wheel', this.onWheel );\n\t\tthis.domElement.addEventListener( 'pointerdown', this.onPointerDown );\n\t\tthis.domElement.addEventListener( 'pointercancel', this.onPointerCancel );\n\n\t\twindow.addEventListener( 'resize', this.onWindowResize );\n\n\t}\n\n\t//listeners\n\n\tonWindowResize = () => {\n\n\t\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\tconst newRadius = this._tbRadius / scale;\n\t\tconst curve = new EllipseCurve( 0, 0, newRadius, newRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\n\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t};\n\n\tonContextMenu = ( event ) => {\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == 2 ) {\n\n\t\t\t\t//prevent only if button 2 is actually used\n\t\t\t\tevent.preventDefault();\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonPointerCancel = () => {\n\n\t\tthis._touchStart.splice( 0, this._touchStart.length );\n\t\tthis._touchCurrent.splice( 0, this._touchCurrent.length );\n\t\tthis._input = INPUT.NONE;\n\n\t};\n\n\tonPointerDown = ( event ) => {\n\n\t\tif ( event.button == 0 && event.isPrimary ) {\n\n\t\t\tthis._downValid = true;\n\t\t\tthis._downEvents.push( event );\n\t\t\tthis._downStart = performance.now();\n\n\t\t} else {\n\n\t\t\tthis._downValid = false;\n\n\t\t}\n\n\t\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\t\tthis._touchStart.push( event );\n\t\t\tthis._touchCurrent.push( event );\n\n\t\t\tswitch ( this._input ) {\n\n\t\t\t\tcase INPUT.NONE:\n\n\t\t\t\t\t//singleStart\n\t\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\n\t\t\t\t\twindow.addEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\t\twindow.addEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.ONE_FINGER:\n\t\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t\t//doubleStart\n\t\t\t\t\tthis._input = INPUT.TWO_FINGER;\n\n\t\t\t\t\tthis.onRotateStart();\n\t\t\t\t\tthis.onPinchStart();\n\t\t\t\t\tthis.onDoublePanStart();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t\t//multipleStart\n\t\t\t\t\tthis._input = INPUT.MULT_FINGER;\n\t\t\t\t\tthis.onTriplePanStart( event );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( event.pointerType != 'touch' && this._input == INPUT.NONE ) {\n\n\t\t\tlet modifier = null;\n\n\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\tmodifier = 'CTRL';\n\n\t\t\t} else if ( event.shiftKey ) {\n\n\t\t\t\tmodifier = 'SHIFT';\n\n\t\t\t}\n\n\t\t\tthis._mouseOp = this.getOpFromAction( event.button, modifier );\n\t\t\tif ( this._mouseOp != null ) {\n\n\t\t\t\twindow.addEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t//singleStart\n\t\t\t\tthis._input = INPUT.CURSOR;\n\t\t\t\tthis._button = event.button;\n\t\t\t\tthis.onSinglePanStart( event, this._mouseOp );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonPointerMove = ( event ) => {\n\n\t\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\t\tswitch ( this._input ) {\n\n\t\t\t\tcase INPUT.ONE_FINGER:\n\n\t\t\t\t\t//singleMove\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onSinglePanMove( event, STATE.ROTATE );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t\tconst movement = this.calculatePointersDistance( this._touchCurrent[ 0 ], event ) * this._devPxRatio;\n\n\t\t\t\t\tif ( movement >= this._switchSensibility ) {\n\n\t\t\t\t\t\t//singleMove\n\t\t\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t\t//rotate/pan/pinchMove\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onRotateMove();\n\t\t\t\t\tthis.onPinchMove();\n\t\t\t\t\tthis.onDoublePanMove();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\t\t//multMove\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onTriplePanMove( event );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\t\tlet modifier = null;\n\n\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\tmodifier = 'CTRL';\n\n\t\t\t} else if ( event.shiftKey ) {\n\n\t\t\t\tmodifier = 'SHIFT';\n\n\t\t\t}\n\n\t\t\tconst mouseOpState = this.getOpStateFromAction( this._button, modifier );\n\n\t\t\tif ( mouseOpState != null ) {\n\n\t\t\t\tthis.onSinglePanMove( event, mouseOpState );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//checkDistance\n\t\tif ( this._downValid ) {\n\n\t\t\tconst movement = this.calculatePointersDistance( this._downEvents[ this._downEvents.length - 1 ], event ) * this._devPxRatio;\n\t\t\tif ( movement > this._movementThreshold ) {\n\n\t\t\t\tthis._downValid = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonPointerUp = ( event ) => {\n\n\t\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\t\tconst nTouch = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nTouch; i ++ ) {\n\n\t\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\t\tthis._touchCurrent.splice( i, 1 );\n\t\t\t\t\tthis._touchStart.splice( i, 1 );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tswitch ( this._input ) {\n\n\t\t\t\tcase INPUT.ONE_FINGER:\n\t\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t\t//singleEnd\n\t\t\t\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\t\tthis.onSinglePanEnd();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t\t//doubleEnd\n\t\t\t\t\tthis.onDoublePanEnd( event );\n\t\t\t\t\tthis.onPinchEnd( event );\n\t\t\t\t\tthis.onRotateEnd( event );\n\n\t\t\t\t\t//switching to singleStart\n\t\t\t\t\tthis._input = INPUT.ONE_FINGER_SWITCHED;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\t\tif ( this._touchCurrent.length == 0 ) {\n\n\t\t\t\t\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\t\t\t\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\t\t\t\t//multCancel\n\t\t\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\t\t\tthis.onTriplePanEnd();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\t\tthis._input = INPUT.NONE;\n\t\t\tthis.onSinglePanEnd();\n\t\t\tthis._button = - 1;\n\n\t\t}\n\n\t\tif ( event.isPrimary ) {\n\n\t\t\tif ( this._downValid ) {\n\n\t\t\t\tconst downTime = event.timeStamp - this._downEvents[ this._downEvents.length - 1 ].timeStamp;\n\n\t\t\t\tif ( downTime <= this._maxDownTime ) {\n\n\t\t\t\t\tif ( this._nclicks == 0 ) {\n\n\t\t\t\t\t\t//first valid click detected\n\t\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst clickInterval = event.timeStamp - this._clickStart;\n\t\t\t\t\t\tconst movement = this.calculatePointersDistance( this._downEvents[ 1 ], this._downEvents[ 0 ] ) * this._devPxRatio;\n\n\t\t\t\t\t\tif ( clickInterval <= this._maxInterval && movement <= this._posThreshold ) {\n\n\t\t\t\t\t\t\t//second valid click detected\n\t\t\t\t\t\t\t//fire double tap and reset values\n\t\t\t\t\t\t\tthis._nclicks = 0;\n\t\t\t\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\t\t\t\t\t\t\tthis.onDoubleTap( event );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//new 'first click'\n\t\t\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\t\t\tthis._downEvents.shift();\n\t\t\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._downValid = false;\n\t\t\t\t\tthis._nclicks = 0;\n\t\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._nclicks = 0;\n\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonWheel = ( event ) => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tlet modifier = null;\n\n\t\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\t\tmodifier = 'CTRL';\n\n\t\t\t} else if ( event.shiftKey ) {\n\n\t\t\t\tmodifier = 'SHIFT';\n\n\t\t\t}\n\n\t\t\tconst mouseOp = this.getOpFromAction( 'WHEEL', modifier );\n\n\t\t\tif ( mouseOp != null ) {\n\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\tconst notchDeltaY = 125; //distance of one notch of mouse wheel\n\t\t\t\tlet sgn = event.deltaY / notchDeltaY;\n\n\t\t\t\tlet size = 1;\n\n\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\tsize = 1 / this.scaleFactor;\n\n\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\tsize = this.scaleFactor;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( mouseOp ) {\n\n\t\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.cursorZoom && this.enablePan ) {\n\n\t\t\t\t\t\t\tlet scalePoint;\n\n\t\t\t\t\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._gizmos.position );\n\n\t\t\t\t\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.camera.quaternion ).add( this._gizmos.position );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, scalePoint ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'FOV':\n\n\t\t\t\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\n\n\t\t\t\t\t\t\t//Vertigo effect\n\n\t\t\t\t\t\t\t//\t  fov / 2\n\t\t\t\t\t\t\t//\t\t|\\\n\t\t\t\t\t\t\t//\t\t| \\\n\t\t\t\t\t\t\t//\t\t|  \\\n\t\t\t\t\t\t\t//\tx\t|\t\\\n\t\t\t\t\t\t\t//\t\t| \t \\\n\t\t\t\t\t\t\t//\t\t| \t  \\\n\t\t\t\t\t\t\t//\t\t| _ _ _\\\n\t\t\t\t\t\t\t//\t\t\ty\n\n\t\t\t\t\t\t\t//check for iOs shift shortcut\n\t\t\t\t\t\t\tif ( event.deltaX != 0 ) {\n\n\t\t\t\t\t\t\t\tsgn = event.deltaX / notchDeltaY;\n\n\t\t\t\t\t\t\t\tsize = 1;\n\n\t\t\t\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\t\tlet xNew = x / size;\t//distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this.camera.fov * 0.5 );\n\n\t\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\t\tif ( newFov > this.maxFov ) {\n\n\t\t\t\t\t\t\t\tnewFov = this.maxFov;\n\n\t\t\t\t\t\t\t} else if ( newFov < this.minFov ) {\n\n\t\t\t\t\t\t\t\tnewFov = this.minFov;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\t\tsize = x / newDistance;\n\n\t\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position, false ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonSinglePanStart = ( event, operation ) => {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( operation ) {\n\n\t\t\t\tcase 'PAN':\n\n\t\t\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\tthis.drawGrid();\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROTATE':\n\n\t\t\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.ROTATE, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\t\t\t\t\tthis.activateGizmos( true );\n\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\tthis._timePrev = this._timeCurrent = performance.now();\n\t\t\t\t\t\tthis._angleCurrent = this._anglePrev = 0;\n\t\t\t\t\t\tthis._cursorPosPrev.copy( this._startCursorPosition );\n\t\t\t\t\t\tthis._cursorPosCurr.copy( this._cursorPosPrev );\n\t\t\t\t\t\tthis._wCurr = 0;\n\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FOV':\n\n\t\t\t\t\tif ( ! this.camera.isPerspectiveCamera || ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\tif ( ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonSinglePanMove = ( event, opState ) => {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tconst restart = opState != this._state;\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( opState ) {\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to pan operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with pan operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to rotate operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with rotate operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbSurface( this.camera, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tconst distance = this._startCursorPosition.distanceTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst angle = this._startCursorPosition.angleTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst amount = Math.max( distance / this._tbRadius, angle ); //effective rotation angle\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.rotate( this.calculateRotationAxis( this._startCursorPosition, this._currentCursorPosition ), amount ) );\n\n\t\t\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\t\t\tthis._timePrev = this._timeCurrent;\n\t\t\t\t\t\t\t\tthis._timeCurrent = performance.now();\n\t\t\t\t\t\t\t\tthis._anglePrev = this._angleCurrent;\n\t\t\t\t\t\t\t\tthis._angleCurrent = amount;\n\t\t\t\t\t\t\t\tthis._cursorPosPrev.copy( this._cursorPosCurr );\n\t\t\t\t\t\t\t\tthis._cursorPosCurr.copy( this._currentCursorPosition );\n\t\t\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\t\t\t\t\t\t\t\tthis._wCurr = this.calculateAngularSpeed( this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.SCALE:\n\n\t\t\t\t\tif ( this.enableZoom ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to zoom operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with zoom operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.FOV:\n\n\t\t\t\t\tif ( this.enableZoom && this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to fov operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with fov operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\t\tnewFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\t\t\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\t\tsize = x / newDistance;\n\t\t\t\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t\t\t\t\t//adjusting distance\n\t\t\t\t\t\t\t_offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\t\t\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonSinglePanEnd = () => {\n\n\t\tif ( this._state == STATE.ROTATE ) {\n\n\n\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t//perform rotation animation\n\t\t\t\tconst deltaTime = ( performance.now() - this._timeCurrent );\n\t\t\t\tif ( deltaTime < 120 ) {\n\n\t\t\t\t\tconst w = Math.abs( ( this._wPrev + this._wCurr ) / 2 );\n\n\t\t\t\t\tconst self = this;\n\t\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\t\tself.updateTbState( STATE.ANIMATION_ROTATE, true );\n\t\t\t\t\t\tconst rotationAxis = self.calculateRotationAxis( self._cursorPosPrev, self._cursorPosCurr );\n\n\t\t\t\t\t\tself.onRotationAnim( t, rotationAxis, Math.min( w, self.wMax ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//cursor has been standing still for over 120 ms since last movement\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else if ( this._state == STATE.PAN || this._state == STATE.IDLE ) {\n\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\tthis.disposeGrid();\n\n\t\t\t}\n\n\t\t\tthis.activateGizmos( false );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonDoubleTap = ( event ) => {\n\n\t\tif ( this.enabled && this.enablePan && this.scene != null ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\t\t\tconst hitP = this.unprojectOnObj( this.getCursorNDC( _center.x, _center.y, this.domElement ), this.camera );\n\n\t\t\tif ( hitP != null && this.enableAnimations ) {\n\n\t\t\t\tconst self = this;\n\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t\t\t}\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.updateTbState( STATE.ANIMATION_FOCUS, true );\n\t\t\t\t\tself.onFocusAnim( t, hitP, self._cameraMatrixState, self._gizmoMatrixState );\n\n\t\t\t\t} );\n\n\t\t\t} else if ( hitP != null && ! this.enableAnimations ) {\n\n\t\t\t\tthis.updateTbState( STATE.FOCUS, true );\n\t\t\t\tthis.focus( hitP, this.scaleFactor );\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonDoublePanStart = () => {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.PAN, true );\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t};\n\n\tonDoublePanMove = () => {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\n\t\t\tif ( this._state != STATE.PAN ) {\n\n\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\tthis._startCursorPosition.copy( this._currentCursorPosition );\n\n\t\t\t}\n\n\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition, true ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonDoublePanEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\n\tonRotateStart = () => {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\n\t\t\t//this._startFingerRotation = event.rotation;\n\n\t\t\tthis._startFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\t\t\tthis._currentFingerRotation = this._startFingerRotation;\n\n\t\t\tthis.camera.getWorldDirection( this._rotationAxis ); //rotation axis\n\n\t\t\tif ( ! this.enablePan && ! this.enableZoom ) {\n\n\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tonRotateMove = () => {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tlet rotationPoint;\n\n\t\t\tif ( this._state != STATE.ZROTATE ) {\n\n\t\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\t\t\t\tthis._startFingerRotation = this._currentFingerRotation;\n\n\t\t\t}\n\n\t\t\t//this._currentFingerRotation = event.rotation;\n\t\t\tthis._currentFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\trotationPoint = new Vector3().setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t} else {\n\n\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\t\t\t\trotationPoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement ).applyQuaternion( this.camera.quaternion ).multiplyScalar( 1 / this.camera.zoom ).add( this._v3_2 );\n\n\t\t\t}\n\n\t\t\tconst amount = MathUtils.DEG2RAD * ( this._startFingerRotation - this._currentFingerRotation );\n\n\t\t\tthis.applyTransformMatrix( this.zRotate( rotationPoint, amount ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonRotateEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.activateGizmos( false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonPinchStart = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\tthis._startFingerDistance = this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] );\n\t\t\tthis._currentFingerDistance = this._startFingerDistance;\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t};\n\n\tonPinchMove = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tconst minDistance = 12; //minimum distance between fingers (in css pixels)\n\n\t\t\tif ( this._state != STATE.SCALE ) {\n\n\t\t\t\tthis._startFingerDistance = this._currentFingerDistance;\n\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t}\n\n\t\t\tthis._currentFingerDistance = Math.max( this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ), minDistance * this._devPxRatio );\n\t\t\tconst amount = this._currentFingerDistance / this._startFingerDistance;\n\n\t\t\tlet scalePoint;\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\tscalePoint = this._gizmos.position;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.camera.quaternion )\n\t\t\t\t\t\t.multiplyScalar( 1 / this.camera.zoom )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.camera, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.camera.quaternion )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.applyTransformMatrix( this.scale( amount, scalePoint ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonPinchEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t};\n\n\tonTriplePanStart = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t}\n\n\t};\n\n\tonTriplePanMove = () => {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\t//\t  fov / 2\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\tx\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t\t| _ _ _\\\n\t\t\t//\t\t\ty\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\tlet size = 1;\n\n\t\t\tif ( movement < 0 ) {\n\n\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t}\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t//check min and max distance\n\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t//calculate new fov\n\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t//check min and max fov\n\t\t\tnewFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\tsize = x / newDistance;\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\tthis.setFov( newFov );\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t//adjusting distance\n\t\t\t_offset.copy( this._gizmos.position ).sub( this.camera.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n\tonTriplePanEnd = () => {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\t\t//this.dispatchEvent( _changeEvent );\n\n\t};\n\n\t/**\n\t * Set _center's x/y coordinates\n\t * @param {Number} clientX\n\t * @param {Number} clientY\n\t */\n\tsetCenter = ( clientX, clientY ) => {\n\n\t\t_center.x = clientX;\n\t\t_center.y = clientY;\n\n\t};\n\n\t/**\n\t * Set default mouse actions\n\t */\n\tinitializeMouseActions = () => {\n\n\t\tthis.setMouseAction( 'PAN', 0, 'CTRL' );\n\t\tthis.setMouseAction( 'PAN', 2 );\n\n\t\tthis.setMouseAction( 'ROTATE', 0 );\n\n\t\tthis.setMouseAction( 'ZOOM', 'WHEEL' );\n\t\tthis.setMouseAction( 'ZOOM', 1 );\n\n\t\tthis.setMouseAction( 'FOV', 'WHEEL', 'SHIFT' );\n\t\tthis.setMouseAction( 'FOV', 1, 'SHIFT' );\n\n\n\t};\n\n\t/**\n\t * Compare two mouse actions\n\t * @param {Object} action1\n\t * @param {Object} action2\n\t * @returns {Boolean} True if action1 and action 2 are the same mouse action, false otherwise\n\t */\n\tcompareMouseAction = ( action1, action2 ) => {\n\n\t\tif ( action1.operation == action2.operation ) {\n\n\t\t\tif ( action1.mouse == action2.mouse && action1.key == action2.key ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n\t * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n\t */\n\tsetMouseAction = ( operation, mouse, key = null ) => {\n\n\t\tconst operationInput = [ 'PAN', 'ROTATE', 'ZOOM', 'FOV' ];\n\t\tconst mouseInput = [ 0, 1, 2, 'WHEEL' ];\n\t\tconst keyInput = [ 'CTRL', 'SHIFT', null ];\n\t\tlet state;\n\n\t\tif ( ! operationInput.includes( operation ) || ! mouseInput.includes( mouse ) || ! keyInput.includes( key ) ) {\n\n\t\t\t//invalid parameters\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( mouse == 'WHEEL' ) {\n\n\t\t\tif ( operation != 'ZOOM' && operation != 'FOV' ) {\n\n\t\t\t\t//cannot associate 2D operation to 1D input\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tswitch ( operation ) {\n\n\t\t\tcase 'PAN':\n\n\t\t\t\tstate = STATE.PAN;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ROTATE':\n\n\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZOOM':\n\n\t\t\t\tstate = STATE.SCALE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'FOV':\n\n\t\t\t\tstate = STATE.FOV;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst action = {\n\n\t\t\toperation: operation,\n\t\t\tmouse: mouse,\n\t\t\tkey: key,\n\t\t\tstate: state\n\n\t\t};\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == action.mouse && this.mouseActions[ i ].key == action.key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1, action );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.mouseActions.push( action );\n\t\treturn true;\n\n\t};\n\n\t/**\n\t * Remove a mouse action by specifying its mouse/key combination\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns {Boolean} True if the operation has been succesfully removed, false otherwise\n\t */\n\tunsetMouseAction = ( mouse, key = null ) => {\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == mouse && this.mouseActions[ i ].key == key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1 );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t/**\n\t * Return the operation associated to a mouse/keyboard combination\n\t * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n\t * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n\t * @returns The operation if it has been found, null otherwise\n\t */\n\tgetOpFromAction = ( mouse, key ) => {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.operation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.operation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n\t * @param {Number} mouse Mouse button\n\t * @param {String} key Keyboard modifier\n\t * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n\t */\n\tgetOpStateFromAction = ( mouse, key ) => {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.state;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.state;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t * Calculate the angle between two pointers\n\t * @param {PointerEvent} p1\n\t * @param {PointerEvent} p2\n\t * @returns {Number} The angle between two pointers in degrees\n\t */\n\tgetAngle = ( p1, p2 ) => {\n\n\t\treturn Math.atan2( p2.clientY - p1.clientY, p2.clientX - p1.clientX ) * 180 / Math.PI;\n\n\t};\n\n\t/**\n\t * Update a PointerEvent inside current pointerevents array\n\t * @param {PointerEvent} event\n\t */\n\tupdateTouchEvent = ( event ) => {\n\n\t\tfor ( let i = 0; i < this._touchCurrent.length; i ++ ) {\n\n\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\tthis._touchCurrent.splice( i, 1, event );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Apply a transformation matrix, to the camera and gizmos\n\t * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n\t */\n\tapplyTransformMatrix( transformation ) {\n\n\t\tif ( transformation.camera != null ) {\n\n\t\t\tthis._m4_1.copy( this._cameraMatrixState ).premultiply( transformation.camera );\n\t\t\tthis._m4_1.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\t\t\tthis.camera.updateMatrix();\n\n\t\t\t//update camera up vector\n\t\t\tif ( this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t\tthis.camera.up.copy( this._upState ).applyQuaternion( this.camera.quaternion );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( transformation.gizmos != null ) {\n\n\t\t\tthis._m4_1.copy( this._gizmoMatrixState ).premultiply( transformation.gizmos );\n\t\t\tthis._m4_1.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t}\n\n\t\tif ( this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\t\tif ( this.adjustNearFar ) {\n\n\t\t\t\tconst cameraDistance = this.camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t\tconst bb = new Box3();\n\t\t\t\tbb.setFromObject( this._gizmos );\n\t\t\t\tconst sphere = new Sphere();\n\t\t\t\tbb.getBoundingSphere( sphere );\n\n\t\t\t\tconst adjustedNearPosition = Math.max( this._nearPos0, sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularNearPosition = cameraDistance - this._initialNear;\n\n\t\t\t\tconst minNearPos = Math.min( adjustedNearPosition, regularNearPosition );\n\t\t\t\tthis.camera.near = cameraDistance - minNearPos;\n\n\n\t\t\t\tconst adjustedFarPosition = Math.min( this._farPos0, - sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularFarPosition = cameraDistance - this._initialFar;\n\n\t\t\t\tconst minFarPos = Math.min( adjustedFarPosition, regularFarPosition );\n\t\t\t\tthis.camera.far = cameraDistance - minFarPos;\n\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t} else {\n\n\t\t\t\tlet update = false;\n\n\t\t\t\tif ( this.camera.near != this._initialNear ) {\n\n\t\t\t\t\tthis.camera.near = this._initialNear;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.camera.far != this._initialFar ) {\n\n\t\t\t\t\tthis.camera.far = this._initialFar;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( update ) {\n\n\t\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculate the angular speed\n\t * @param {Number} p0 Position at t0\n\t * @param {Number} p1 Position at t1\n\t * @param {Number} t0 Initial time in milliseconds\n\t * @param {Number} t1 Ending time in milliseconds\n\t */\n\tcalculateAngularSpeed = ( p0, p1, t0, t1 ) => {\n\n\t\tconst s = p1 - p0;\n\t\tconst t = ( t1 - t0 ) / 1000;\n\t\tif ( t == 0 ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\treturn s / t;\n\n\t};\n\n\t/**\n\t * Calculate the distance between two pointers\n\t * @param {PointerEvent} p0 The first pointer\n\t * @param {PointerEvent} p1 The second pointer\n\t * @returns {number} The distance between the two pointers\n\t */\n\tcalculatePointersDistance = ( p0, p1 ) => {\n\n\t\treturn Math.sqrt( Math.pow( p1.clientX - p0.clientX, 2 ) + Math.pow( p1.clientY - p0.clientY, 2 ) );\n\n\t};\n\n\t/**\n\t * Calculate the rotation axis as the vector perpendicular between two vectors\n\t * @param {Vector3} vec1 The first vector\n\t * @param {Vector3} vec2 The second vector\n\t * @returns {Vector3} The normalized rotation axis\n\t */\n\tcalculateRotationAxis = ( vec1, vec2 ) => {\n\n\t\tthis._rotationMatrix.extractRotation( this._cameraMatrixState );\n\t\tthis._quat.setFromRotationMatrix( this._rotationMatrix );\n\n\t\tthis._rotationAxis.crossVectors( vec1, vec2 ).applyQuaternion( this._quat );\n\t\treturn this._rotationAxis.normalize().clone();\n\n\t};\n\n\t/**\n\t * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n\t * @param {Camera} camera\n\t * @returns {Number} The trackball radius\n\t */\n\tcalculateTbRadius = ( camera ) => {\n\n\t\tconst distance = camera.position.distanceTo( this._gizmos.position );\n\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tconst halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\t\t\tconst halfFovH = Math.atan( ( camera.aspect ) * Math.tan( halfFovV ) ); //horizontal fov/2 in radians\n\t\t\treturn Math.tan( Math.min( halfFovV, halfFovH ) ) * distance * this.radiusFactor;\n\n\t\t} else if ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\treturn Math.min( camera.top, camera.right ) * this.radiusFactor;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n\t * @param {Vector3} point The point of interest\n\t * @param {Number} size Scale factor\n\t * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n\t */\n\tfocus = ( point, size, amount = 1 ) => {\n\n\t\t//move center of camera (along with gizmos) towards point of interest\n\t\t_offset.copy( point ).sub( this._gizmos.position ).multiplyScalar( amount );\n\t\tthis._translationMatrix.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t_gizmoMatrixStateTemp.copy( this._gizmoMatrixState );\n\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t_cameraMatrixStateTemp.copy( this._cameraMatrixState );\n\t\tthis._cameraMatrixState.premultiply( this._translationMatrix );\n\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\n\t\t//apply zoom\n\t\tif ( this.enableZoom ) {\n\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.copy( _gizmoMatrixStateTemp );\n\t\tthis._cameraMatrixState.copy( _cameraMatrixStateTemp );\n\n\t};\n\n\t/**\n\t * Draw a grid and add it to the scene\n\t */\n\tdrawGrid = () => {\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tconst color = 0x888888;\n\t\t\tconst multiplier = 3;\n\t\t\tlet size, divisions, maxLength, tick;\n\n\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\tconst width = this.camera.right - this.camera.left;\n\t\t\t\tconst height = this.camera.bottom - this.camera.top;\n\n\t\t\t\tmaxLength = Math.max( width, height );\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength / this.camera.zoom * multiplier;\n\t\t\t\tdivisions = size / tick * this.camera.zoom;\n\n\t\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tconst distance = this.camera.position.distanceTo( this._gizmos.position );\n\t\t\t\tconst halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n\t\t\t\tconst halfFovH = Math.atan( ( this.camera.aspect ) * Math.tan( halfFovV ) );\n\n\t\t\t\tmaxLength = Math.tan( Math.max( halfFovV, halfFovH ) ) * distance * 2;\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength * multiplier;\n\t\t\t\tdivisions = size / tick;\n\n\t\t\t}\n\n\t\t\tif ( this._grid == null ) {\n\n\t\t\t\tthis._grid = new GridHelper( size, divisions, color, color );\n\t\t\t\tthis._grid.position.copy( this._gizmos.position );\n\t\t\t\tthis._gridPosition.copy( this._grid.position );\n\t\t\t\tthis._grid.quaternion.copy( this.camera.quaternion );\n\t\t\t\tthis._grid.rotateX( Math.PI * 0.5 );\n\n\t\t\t\tthis.scene.add( this._grid );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Remove all listeners, stop animations and clean scene\n\t */\n\tdispose = () => {\n\n\t\tif ( this._animationId != - 1 ) {\n\n\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t}\n\n\t\tthis.domElement.removeEventListener( 'pointerdown', this.onPointerDown );\n\t\tthis.domElement.removeEventListener( 'pointercancel', this.onPointerCancel );\n\t\tthis.domElement.removeEventListener( 'wheel', this.onWheel );\n\t\tthis.domElement.removeEventListener( 'contextmenu', this.onContextMenu );\n\n\t\twindow.removeEventListener( 'pointermove', this.onPointerMove );\n\t\twindow.removeEventListener( 'pointerup', this.onPointerUp );\n\n\t\twindow.removeEventListener( 'resize', this.onWindowResize );\n\n\t\tif ( this.scene !== null ) this.scene.remove( this._gizmos );\n\t\tthis.disposeGrid();\n\n\t};\n\n\t/**\n\t * remove the grid from the scene\n\t */\n\tdisposeGrid = () => {\n\n\t\tif ( this._grid != null && this.scene != null ) {\n\n\t\t\tthis.scene.remove( this._grid );\n\t\t\tthis._grid = null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Compute the easing out cubic function for ease out effect in animation\n\t * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n\t * @returns {Number} Result of easing out cubic at time t\n\t */\n\teaseOutCubic = ( t ) => {\n\n\t\treturn 1 - Math.pow( 1 - t, 3 );\n\n\t};\n\n\t/**\n\t * Make rotation gizmos more or less visible\n\t * @param {Boolean} isActive If true, make gizmos more visible\n\t */\n\tactivateGizmos = ( isActive ) => {\n\n\t\tconst gizmoX = this._gizmos.children[ 0 ];\n\t\tconst gizmoY = this._gizmos.children[ 1 ];\n\t\tconst gizmoZ = this._gizmos.children[ 2 ];\n\n\t\tif ( isActive ) {\n\n\t\t\tgizmoX.material.setValues( { opacity: 1 } );\n\t\t\tgizmoY.material.setValues( { opacity: 1 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 1 } );\n\n\t\t} else {\n\n\t\t\tgizmoX.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoY.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 0.6 } );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Calculate the cursor position in NDC\n\t * @param {number} x Cursor horizontal coordinate within the canvas\n\t * @param {number} y Cursor vertical coordinate within the canvas\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @returns {Vector2} Cursor normalized position inside the canvas\n\t */\n\tgetCursorNDC = ( cursorX, cursorY, canvas ) => {\n\n\t\tconst canvasRect = canvas.getBoundingClientRect();\n\t\tthis._v2_1.setX( ( ( cursorX - canvasRect.left ) / canvasRect.width ) * 2 - 1 );\n\t\tthis._v2_1.setY( ( ( canvasRect.bottom - cursorY ) / canvasRect.height ) * 2 - 1 );\n\t\treturn this._v2_1.clone();\n\n\t};\n\n\t/**\n\t * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n\t * @param {Number} x Cursor horizontal coordinate within the canvas\n\t * @param {Number} y Cursor vertical coordinate within the canvas\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @returns {Vector2} Cursor position inside the canvas\n\t */\n\tgetCursorPosition = ( cursorX, cursorY, canvas ) => {\n\n\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\t\tthis._v2_1.x *= ( this.camera.right - this.camera.left ) * 0.5;\n\t\tthis._v2_1.y *= ( this.camera.top - this.camera.bottom ) * 0.5;\n\t\treturn this._v2_1.clone();\n\n\t};\n\n\t/**\n\t * Set the camera to be controlled\n\t * @param {Camera} camera The virtual camera to be controlled\n\t */\n\tsetCamera = ( camera ) => {\n\n\t\tcamera.lookAt( this.target );\n\t\tcamera.updateMatrix();\n\n\t\t//setting state\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._fov0 = camera.fov;\n\t\t\tthis._fovState = camera.fov;\n\n\t\t}\n\n\t\tthis._cameraMatrixState0.copy( camera.matrix );\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraProjectionState.copy( camera.projectionMatrix );\n\t\tthis._zoom0 = camera.zoom;\n\t\tthis._zoomState = this._zoom0;\n\n\t\tthis._initialNear = camera.near;\n\t\tthis._nearPos0 = camera.position.distanceTo( this.target ) - camera.near;\n\t\tthis._nearPos = this._initialNear;\n\n\t\tthis._initialFar = camera.far;\n\t\tthis._farPos0 = camera.position.distanceTo( this.target ) - camera.far;\n\t\tthis._farPos = this._initialFar;\n\n\t\tthis._up0.copy( camera.up );\n\t\tthis._upState.copy( camera.up );\n\n\t\tthis.camera = camera;\n\t\tthis.camera.updateProjectionMatrix();\n\n\t\t//making gizmos\n\t\tthis._tbRadius = this.calculateTbRadius( camera );\n\t\tthis.makeGizmos( this.target, this._tbRadius );\n\n\t};\n\n\t/**\n\t * Set gizmos visibility\n\t * @param {Boolean} value Value of gizmos visibility\n\t */\n\tsetGizmosVisible( value ) {\n\n\t\tthis._gizmos.visible = value;\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Set gizmos radius factor and redraws gizmos\n\t * @param {Float} value Value of radius factor\n\t */\n\tsetTbRadius( value ) {\n\n\t\tthis.radiusFactor = value;\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\tconst curve = new EllipseCurve( 0, 0, this._tbRadius, this._tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\n\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Creates the rotation gizmos matching trackball center and radius\n\t * @param {Vector3} tbCenter The trackball center\n\t * @param {number} tbRadius The trackball radius\n\t */\n\tmakeGizmos = ( tbCenter, tbRadius ) => {\n\n\t\tconst curve = new EllipseCurve( 0, 0, tbRadius, tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\n\t\t//geometry\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\t\t//material\n\t\tconst curveMaterialX = new LineBasicMaterial( { color: 0xff8080, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialY = new LineBasicMaterial( { color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialZ = new LineBasicMaterial( { color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 } );\n\n\t\t//line\n\t\tconst gizmoX = new Line( curveGeometry, curveMaterialX );\n\t\tconst gizmoY = new Line( curveGeometry, curveMaterialY );\n\t\tconst gizmoZ = new Line( curveGeometry, curveMaterialZ );\n\n\t\tconst rotation = Math.PI * 0.5;\n\t\tgizmoX.rotation.x = rotation;\n\t\tgizmoY.rotation.y = rotation;\n\n\n\t\t//setting state\n\t\tthis._gizmoMatrixState0.identity().setPosition( tbCenter );\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\n\t\tif ( this.camera.zoom !== 1 ) {\n\n\t\t\t//adapt gizmos size to camera zoom\n\t\t\tconst size = 1 / this.camera.zoom;\n\t\t\tthis._scaleMatrix.makeScale( size, size, size );\n\t\t\tthis._translationMatrix.makeTranslation( - tbCenter.x, - tbCenter.y, - tbCenter.z );\n\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix ).premultiply( this._scaleMatrix );\n\t\t\tthis._translationMatrix.makeTranslation( tbCenter.x, tbCenter.y, tbCenter.z );\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t//\n\n\t\tthis._gizmos.traverse( function ( object ) {\n\n\t\t\tif ( object.isLine ) {\n\n\t\t\t\tobject.geometry.dispose();\n\t\t\t\tobject.material.dispose();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis._gizmos.clear();\n\n\t\t//\n\n\t\tthis._gizmos.add( gizmoX );\n\t\tthis._gizmos.add( gizmoY );\n\t\tthis._gizmos.add( gizmoZ );\n\n\t};\n\n\t/**\n\t * Perform animation for focus operation\n\t * @param {Number} time Instant in which this function is called as performance.now()\n\t * @param {Vector3} point Point of interest for focus operation\n\t * @param {Matrix4} cameraMatrix Camera matrix\n\t * @param {Matrix4} gizmoMatrix Gizmos matrix\n\t */\n\tonFocusAnim = ( time, point, cameraMatrix, gizmoMatrix ) => {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tconst deltaTime = time - this._timeStart;\n\t\t\tconst animTime = deltaTime / this.focusAnimationTime;\n\n\t\t\tthis._gizmoMatrixState.copy( gizmoMatrix );\n\n\t\t\tif ( animTime >= 1 ) {\n\n\t\t\t\t//animation end\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\t\tthis.focus( point, this.scaleFactor );\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t} else {\n\n\t\t\t\tconst amount = this.easeOutCubic( animTime );\n\t\t\t\tconst size = ( ( 1 - amount ) + ( this.scaleFactor * amount ) );\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\t\tthis.focus( point, size, amount );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onFocusAnim( t, point, cameraMatrix, gizmoMatrix.clone() );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Perform animation for rotation operation\n\t * @param {Number} time Instant in which this function is called as performance.now()\n\t * @param {Vector3} rotationAxis Rotation axis\n\t * @param {number} w0 Initial angular velocity\n\t */\n\tonRotationAnim = ( time, rotationAxis, w0 ) => {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._anglePrev = 0;\n\t\t\tthis._angleCurrent = 0;\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t//w = w0 + alpha * t\n\t\t\tconst deltaTime = ( time - this._timeStart ) / 1000;\n\t\t\tconst w = w0 + ( ( - this.dampingFactor ) * deltaTime );\n\n\t\t\tif ( w > 0 ) {\n\n\t\t\t\t//tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n\t\t\t\tthis._angleCurrent = 0.5 * ( - this.dampingFactor ) * Math.pow( deltaTime, 2 ) + w0 * deltaTime + 0;\n\t\t\t\tthis.applyTransformMatrix( this.rotate( rotationAxis, this._angleCurrent ) );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onRotationAnim( t, rotationAxis, w0 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis._animationId = - 1;\n\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t\tif ( this._state != STATE.ROTATE ) {\n\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\t/**\n\t * Perform pan operation moving camera between two points\n\t * @param {Vector3} p0 Initial point\n\t * @param {Vector3} p1 Ending point\n\t * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n\t */\n\tpan = ( p0, p1, adjust = false ) => {\n\n\t\tconst movement = p0.clone().sub( p1 );\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//adjust movement amount\n\t\t\tmovement.multiplyScalar( 1 / this.camera.zoom );\n\n\t\t} else if ( this.camera.isPerspectiveCamera && adjust ) {\n\n\t\t\t//adjust movement amount\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState0 );\t//camera's initial position\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 );\t//gizmo's initial position\n\t\t\tconst distanceFactor = this._v3_1.distanceTo( this._v3_2 ) / this.camera.position.distanceTo( this._gizmos.position );\n\t\t\tmovement.multiplyScalar( 1 / distanceFactor );\n\n\t\t}\n\n\t\tthis._v3_1.set( movement.x, movement.y, 0 ).applyQuaternion( this.camera.quaternion );\n\n\t\tthis._m4_1.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_1 );\n\t\treturn _transformation;\n\n\t};\n\n\t/**\n\t * Reset trackball\n\t */\n\treset = () => {\n\n\t\tthis.camera.zoom = this._zoom0;\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis.camera.fov = this._fov0;\n\n\t\t}\n\n\t\tthis.camera.near = this._nearPos;\n\t\tthis.camera.far = this._farPos;\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\t\tthis.camera.up.copy( this._up0 );\n\n\t\tthis.camera.updateMatrix();\n\t\tthis.camera.updateProjectionMatrix();\n\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\t\tthis._gizmoMatrixState0.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\tthis._gizmos.updateMatrix();\n\n\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\n\t\tthis.camera.lookAt( this._gizmos.position );\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t};\n\n\t/**\n\t * Rotate the camera around an axis passing by trackball's center\n\t * @param {Vector3} axis Rotation axis\n\t * @param {number} angle Angle in radians\n\t * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n\t */\n\trotate = ( axis, angle ) => {\n\n\t\tconst point = this._gizmos.position; //rotation center\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\t\tthis._rotationMatrix.makeRotationAxis( axis, - angle );\n\n\t\t//rotate camera\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\treturn _transformation;\n\n\t};\n\n\tcopyState = () => {\n\n\t\tlet state;\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\tstate = JSON.stringify( { arcballState: {\n\n\t\t\t\tcameraFar: this.camera.far,\n\t\t\t\tcameraMatrix: this.camera.matrix,\n\t\t\t\tcameraNear: this.camera.near,\n\t\t\t\tcameraUp: this.camera.up,\n\t\t\t\tcameraZoom: this.camera.zoom,\n\t\t\t\tgizmoMatrix: this._gizmos.matrix\n\n\t\t\t} } );\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tstate = JSON.stringify( { arcballState: {\n\t\t\t\tcameraFar: this.camera.far,\n\t\t\t\tcameraFov: this.camera.fov,\n\t\t\t\tcameraMatrix: this.camera.matrix,\n\t\t\t\tcameraNear: this.camera.near,\n\t\t\t\tcameraUp: this.camera.up,\n\t\t\t\tcameraZoom: this.camera.zoom,\n\t\t\t\tgizmoMatrix: this._gizmos.matrix\n\n\t\t\t} } );\n\n\t\t}\n\n\t\tnavigator.clipboard.writeText( state );\n\n\t};\n\n\tpasteState = () => {\n\n\t\tconst self = this;\n\t\tnavigator.clipboard.readText().then( function resolved( value ) {\n\n\t\t\tself.setStateFromJSON( value );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Save the current state of the control. This can later be recover with .reset\n\t */\n\tsaveState = () => {\n\n\t\tthis._cameraMatrixState0.copy( this.camera.matrix );\n\t\tthis._gizmoMatrixState0.copy( this._gizmos.matrix );\n\t\tthis._nearPos = this.camera.near;\n\t\tthis._farPos = this.camera.far;\n\t\tthis._zoom0 = this.camera.zoom;\n\t\tthis._up0.copy( this.camera.up );\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._fov0 = this.camera.fov;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Perform uniform scale operation around a given point\n\t * @param {Number} size Scale factor\n\t * @param {Vector3} point Point around which scale\n\t * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n\t * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n\t */\n\tscale = ( size, point, scaleGizmos = true ) => {\n\n\t\t_scalePointTemp.copy( point );\n\t\tlet sizeInverse = 1 / size;\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//camera zoom\n\t\t\tthis.camera.zoom = this._zoomState;\n\t\t\tthis.camera.zoom *= size;\n\n\t\t\t//check min and max zoom\n\t\t\tif ( this.camera.zoom > this.maxZoom ) {\n\n\t\t\t\tthis.camera.zoom = this.maxZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.maxZoom;\n\n\t\t\t} else if ( this.camera.zoom < this.minZoom ) {\n\n\t\t\t\tthis.camera.zoom = this.minZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.minZoom;\n\n\t\t\t}\n\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\t//gizmos position\n\n\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\t\t\tthis._translationMatrix.makeTranslation( - this._v3_1.x, - this._v3_1.y, - this._v3_1.z );\n\n\t\t\tthis._m4_2.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ).multiply( this._scaleMatrix );\n\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\n\n\t\t\t//move camera and gizmos to obtain pinch effect\n\t\t\t_scalePointTemp.sub( this._v3_1 );\n\n\t\t\tconst amount = _scalePointTemp.clone().multiplyScalar( sizeInverse );\n\t\t\t_scalePointTemp.sub( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z );\n\t\t\tthis._m4_2.premultiply( this._m4_1 );\n\n\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\t\treturn _transformation;\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t//move camera\n\t\t\tlet distance = this._v3_1.distanceTo( _scalePointTemp );\n\t\t\tlet amount = distance - ( distance * sizeInverse );\n\n\t\t\t//check min and max distance\n\t\t\tconst newDistance = distance - amount;\n\t\t\tif ( newDistance < this.minDistance ) {\n\n\t\t\t\tsizeInverse = this.minDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t} else if ( newDistance > this.maxDistance ) {\n\n\t\t\t\tsizeInverse = this.maxDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t}\n\n\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_1 ).normalize().multiplyScalar( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\n\t\t\tif ( scaleGizmos ) {\n\n\t\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\t\tconst pos = this._v3_2;\n\n\t\t\t\tdistance = pos.distanceTo( _scalePointTemp );\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\t\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_2 ).normalize().multiplyScalar( amount );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( pos.x, pos.y, pos.z );\n\t\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\n\t\t\t\tthis._m4_2.makeTranslation( _offset.x, _offset.y, _offset.z ).multiply( this._translationMatrix );\n\t\t\t\tthis._m4_2.multiply( this._scaleMatrix );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( - pos.x, - pos.y, - pos.z );\n\n\t\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\t\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\n\n\t\t\t} else {\n\n\t\t\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\t\t}\n\n\t\t\treturn _transformation;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Set camera fov\n\t * @param {Number} value fov to be setted\n\t */\n\tsetFov = ( value ) => {\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis.camera.fov = MathUtils.clamp( value, this.minFov, this.maxFov );\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Set values in transformation object\n\t * @param {Matrix4} camera Transformation to be applied to the camera\n\t * @param {Matrix4} gizmos Transformation to be applied to gizmos\n\t */\n\t setTransformationMatrices( camera = null, gizmos = null ) {\n\n\t\tif ( camera != null ) {\n\n\t\t\tif ( _transformation.camera != null ) {\n\n\t\t\t\t_transformation.camera.copy( camera );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.camera = camera.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.camera = null;\n\n\t\t}\n\n\t\tif ( gizmos != null ) {\n\n\t\t\tif ( _transformation.gizmos != null ) {\n\n\t\t\t\t_transformation.gizmos.copy( gizmos );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.gizmos = gizmos.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.gizmos = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Rotate camera around its direction axis passing by a given point by a given angle\n\t * @param {Vector3} point The point where the rotation axis is passing trough\n\t * @param {Number} angle Angle in radians\n\t * @returns The computed transormation matix\n\t */\n\tzRotate = ( point, angle ) => {\n\n\t\tthis._rotationMatrix.makeRotationAxis( this._rotationAxis, angle );\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState ).sub( point );\t//vector from rotation center to gizmos position\n\t\tthis._v3_2.copy( this._v3_1 ).applyAxisAngle( this._rotationAxis, angle );\t//apply rotation\n\t\tthis._v3_2.sub( this._v3_1 );\n\n\t\tthis._m4_2.makeTranslation( this._v3_2.x, this._v3_2.y, this._v3_2.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\treturn _transformation;\n\n\t};\n\n\n\tgetRaycaster() {\n\n\t\treturn _raycaster;\n\n\t}\n\n\n\t/**\n\t * Unproject the cursor on the 3D object surface\n\t * @param {Vector2} cursor Cursor coordinates in NDC\n\t * @param {Camera} camera Virtual camera\n\t * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n\t */\n\tunprojectOnObj = ( cursor, camera ) => {\n\n\t\tconst raycaster = this.getRaycaster();\n\t\traycaster.near = camera.near;\n\t\traycaster.far = camera.far;\n\t\traycaster.setFromCamera( cursor, camera );\n\n\t\tconst intersect = raycaster.intersectObjects( this.scene.children, true );\n\n\t\tfor ( let i = 0; i < intersect.length; i ++ ) {\n\n\t\t\tif ( intersect[ i ].object.uuid != this._gizmos.uuid && intersect[ i ].face != null ) {\n\n\t\t\t\treturn intersect[ i ].point.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t * Unproject the cursor on the trackball surface\n\t * @param {Camera} camera The virtual camera\n\t * @param {Number} cursorX Cursor horizontal coordinate on screen\n\t * @param {Number} cursorY Cursor vertical coordinate on screen\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @param {number} tbRadius The trackball radius\n\t * @returns {Vector3} The unprojected point on the trackball surface\n\t */\n\tunprojectOnTbSurface = ( camera, cursorX, cursorY, canvas, tbRadius ) => {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\tconst x2 = Math.pow( this._v2_1.x, 2 );\n\t\t\tconst y2 = Math.pow( this._v2_1.y, 2 );\n\t\t\tconst r2 = Math.pow( this._tbRadius, 2 );\n\n\t\t\tif ( x2 + y2 <= r2 * 0.5 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v3_1.setZ( Math.sqrt( r2 - ( x2 + y2 ) ) );\n\n\t\t\t} else {\n\n\t\t\t\t//intersection with hyperboloid\n\t\t\t\tthis._v3_1.setZ( ( r2 * 0.5 ) / ( Math.sqrt( x2 + y2 ) ) );\n\n\t\t\t}\n\n\t\t\treturn this._v3_1;\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\t\t\tconst cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\t\t\tconst radius2 = Math.pow( tbRadius, 2 );\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( this._v3_1.x, this._v3_1.y, tbRadius );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and trackball surface\n\t\t\t *|y = m * x + q\n\t\t\t *|x^2 + y^2 = r^2\n\t\t\t *\n\t\t\t * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n\t\t\t */\n\t\t\tlet a = Math.pow( m, 2 ) + 1;\n\t\t\tlet b = 2 * m * q;\n\t\t\tlet c = Math.pow( q, 2 ) - radius2;\n\t\t\tlet delta = Math.pow( b, 2 ) - ( 4 * a * c );\n\n\t\t\tif ( delta >= 0 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\t\tconst angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n\t\t\t\tif ( angle >= 45 ) {\n\n\t\t\t\t\t//if angle between intersection point and X' axis is >= 45°, return that point\n\t\t\t\t\t//otherwise, calculate intersection point with hyperboloid\n\n\t\t\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\t\t\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\t\t\treturn rayDir;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//intersection with hyperboloid\n\t\t\t/*\n\t\t\t *|y = m * x + q\n\t\t\t *|y = (1 / x) * (r^2 / 2)\n\t\t\t *\n\t\t\t * m * x^2 + q * x - r^2 / 2 = 0\n\t\t\t */\n\n\t\t\ta = m;\n\t\t\tb = q;\n\t\t\tc = - radius2 * 0.5;\n\t\t\tdelta = Math.pow( b, 2 ) - ( 4 * a * c );\n\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t};\n\n\n\t/**\n\t * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n\t * @param {Camera} camera The virtual camera\n\t * @param {Number} cursorX Cursor horizontal coordinate on screen\n\t * @param {Number} cursorY Cursor vertical coordinate on screen\n\t * @param {HTMLElement} canvas The canvas where the renderer draws its output\n\t * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n\t * @returns {Vector3} The unprojected point on the trackball plane\n\t */\n\tunprojectOnTbPlane = ( camera, cursorX, cursorY, canvas, initialDistance = false ) => {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\treturn this._v3_1.clone();\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\t\t\tlet cameraGizmoDistance;\n\n\t\t\tif ( initialDistance ) {\n\n\t\t\t\tcameraGizmoDistance = this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ).distanceTo( this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ) );\n\n\t\t\t} else {\n\n\t\t\t\tcameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and the plane\n\t\t\t *|y = mx + q\n\t\t\t *|y = 0\n\t\t\t *\n\t\t\t * x = -q/m\n\t\t\t*/\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( 0, 0, 0 );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\t\t\tconst x = - q / m;\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( q, 2 ) + Math.pow( x, 2 ) );\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z = 0;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Update camera and gizmos state\n\t */\n\tupdateMatrixState = () => {\n\n\t\t//update camera and gizmos state\n\t\tthis._cameraMatrixState.copy( this.camera.matrix );\n\t\tthis._gizmoMatrixState.copy( this._gizmos.matrix );\n\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\tthis._cameraProjectionState.copy( this.camera.projectionMatrix );\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\tthis._zoomState = this.camera.zoom;\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\tthis._fovState = this.camera.fov;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Update the trackball FSA\n\t * @param {STATE} newState New state of the FSA\n\t * @param {Boolean} updateMatrices If matriices state should be updated\n\t */\n\tupdateTbState = ( newState, updateMatrices ) => {\n\n\t\tthis._state = newState;\n\t\tif ( updateMatrices ) {\n\n\t\t\tthis.updateMatrixState();\n\n\t\t}\n\n\t};\n\n\tupdate = () => {\n\n\t\tconst EPS = 0.000001;\n\n\t\tif ( this.target.equals( this._currentTarget ) === false ) {\n\n\t\t\tthis._gizmos.position.copy( this.target );\t//for correct radius calculation\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\t\tthis.makeGizmos( this.target, this._tbRadius );\n\t\t\tthis._currentTarget.copy( this.target );\n\n\t\t}\n\n\t\t//check min/max parameters\n\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t//check zoom\n\t\t\tif ( this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom ) {\n\n\t\t\t\tconst newZoom = MathUtils.clamp( this.camera.zoom, this.minZoom, this.maxZoom );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newZoom / this.camera.zoom, this._gizmos.position, true ) );\n\n\t\t\t}\n\n\t\t} else if ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t//check distance\n\t\t\tconst distance = this.camera.position.distanceTo( this._gizmos.position );\n\n\t\t\tif ( distance > this.maxDistance + EPS || distance < this.minDistance - EPS ) {\n\n\t\t\t\tconst newDistance = MathUtils.clamp( distance, this.minDistance, this.maxDistance );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newDistance / distance, this._gizmos.position ) );\n\t\t\t\tthis.updateMatrixState();\n\n\t\t\t }\n\n\t\t\t//check fov\n\t\t\tif ( this.camera.fov < this.minFov || this.camera.fov > this.maxFov ) {\n\n\t\t\t\tthis.camera.fov = MathUtils.clamp( this.camera.fov, this.minFov, this.maxFov );\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tconst oldRadius = this._tbRadius;\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\n\t\t\tif ( oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS ) {\n\n\t\t\t\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\t\t\t\tconst newRadius = this._tbRadius / scale;\n\t\t\t\tconst curve = new EllipseCurve( 0, 0, newRadius, newRadius );\n\t\t\t\tconst points = curve.getPoints( this._curvePts );\n\t\t\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\t\t\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.camera.lookAt( this._gizmos.position );\n\n\t};\n\n\tsetStateFromJSON = ( json ) => {\n\n\t\tconst state = JSON.parse( json );\n\n\t\tif ( state.arcballState != undefined ) {\n\n\t\t\tthis._cameraMatrixState.fromArray( state.arcballState.cameraMatrix.elements );\n\t\t\tthis._cameraMatrixState.decompose( this.camera.position, this.camera.quaternion, this.camera.scale );\n\n\t\t\tthis.camera.up.copy( state.arcballState.cameraUp );\n\t\t\tthis.camera.near = state.arcballState.cameraNear;\n\t\t\tthis.camera.far = state.arcballState.cameraFar;\n\n\t\t\tthis.camera.zoom = state.arcballState.cameraZoom;\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\tthis.camera.fov = state.arcballState.cameraFov;\n\n\t\t\t}\n\n\t\t\tthis._gizmoMatrixState.fromArray( state.arcballState.gizmoMatrix.elements );\n\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\tthis.camera.updateMatrix();\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.camera );\n\t\t\tconst gizmoTmp = new Matrix4().copy( this._gizmoMatrixState0 );\n\t\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\t\t\tthis._gizmoMatrixState0.copy( gizmoTmp );\n\n\t\t\tthis.camera.lookAt( this._gizmos.position );\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t};\n\n}\n\nexport { ArcballControls };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}